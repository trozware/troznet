<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>
        SwiftUI Data Flow ::
        TrozWare
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="SwiftUI gives us a completely new way to lay out out user interfaces, in a declarative and responsive way. Your data dictates what is displayed. But this leads to a new problem - how should the data models be constructed and how can they be passed around between the various views that make up your app?
In this post, I intend to discuss the possibilities with examples.
Update - January 2021: I think the information in this post is still all valid except for one change. When you are initializing an ObservableObject, you should use @StateObject instead of @ObservedObject. Your views can receive objects that are owned by other views as @ObservedObject or @EnvironmentObject but the owner of the data should always create the data object with @StateObject.
"
/>
<meta name="keywords" content="[Swift Apple macOS iOS Apple Watch]" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://troz.net/post/2019/swiftui-data-flow/" />





 
<link rel="stylesheet" href="/css/style.css" />

<link rel="stylesheet" href="https://troz.net/style.css" />


<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
<link rel="manifest" href="/site.webmanifest" />
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
<meta name="msapplication-TileColor" content="#da532c" />
<meta name="theme-color" content="#ffffff" />


<link href="/fonts/Inter-Italic.woff2"
rel="preload" type="font/woff2" as="font" crossorigin=""> <link href="/fonts/Inter-Regular.woff2" rel="preload"
type="font/woff2" as="font" crossorigin=""> <link href="/fonts/Inter-Medium.woff2" rel="preload" type="font/woff2"
as="font" crossorigin=""> <link href="/fonts/Inter-MediumItalic.woff2" rel="preload"
type="font/woff2" as="font" crossorigin=""> <link href="/fonts/Inter-Bold.woff2" rel="preload" type="font/woff2"
as="font" crossorigin=""> <link href="/fonts/Inter-BoldItalic.woff2" rel="preload" type="font/woff2"
as="font" crossorigin="">


<meta property="og:url" content="https://troz.net/post/2019/swiftui-data-flow/">
  <meta property="og:site_name" content="TrozWare">
  <meta property="og:title" content="SwiftUI Data Flow">
  <meta property="og:description" content="Various ways to pass data around your SwiftUI apps.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2021-01-24T15:17:14+10:00">
    <meta property="article:modified_time" content="2021-01-24T15:17:14+10:00">
    <meta property="article:tag" content="Swift">
    <meta property="article:tag" content="Swiftui">






  </head>
  <body >
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="https://troz.net/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >TrozWare</span
    >
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/">Home</a></li>
        
      
        
          <li><a href="/books/">Books</a></li>
        
      
        
          <li><a href="/apps/">Apps</a></li>
        
      
        
          <li><a href="/post/">Archives</a></li>
        
      
        
          <li><a href="/tags/">Tags</a></li>
        
      
        
          <li><a href="/contact/">Contact</a></li>
        
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/">Home</a></li>
      
    
      
        <li><a href="/books/">Books</a></li>
      
    
      
        <li><a href="/apps/">Apps</a></li>
      
    
      
        <li><a href="/post/">Archives</a></li>
      
    
      
        <li><a href="/tags/">Tags</a></li>
      
    
      
        <li><a href="/contact/">Contact</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none" />
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        

<link rel="stylesheet" href="/css/header.css" />

<div class="post">
  <h2 class="post-title">
    <a href="https://troz.net/post/2019/swiftui-data-flow/">SwiftUI Data Flow</a>
  </h2>
  <div class="post-meta">
    <span class="post-date">
      24 Jan 2021
    </span>
    <span class="more-meta">- 3515 words, </span>
    <span class="more-meta"> 17 minute read</span>
  </div>

  
  <span class="post-tags">
     #<a
      href="https://troz.net/tags/swift"
      >swift</a
    >&nbsp;  #<a
      href="https://troz.net/tags/swiftui"
      >swiftui</a
    >&nbsp; 
  </span>
   

  <div class="post-content"><p><a href="https://developer.apple.com/xcode/swiftui/">SwiftUI</a> gives us a completely new way to lay out out user interfaces, in a declarative and responsive way. Your data dictates what is displayed. But this leads to a new problem - how should the data models be constructed and how can they be passed around between the various views that make up your app?</p>
<p>In this post, I intend to discuss the possibilities with examples.</p>
<p><strong>Update - January 2021:</strong> I think the information in this post is still all valid except for one change. When you are initializing an ObservableObject, you should use <code>@StateObject</code> instead of <code>@ObservedObject</code>. Your views can receive objects that are owned by other views as <code>@ObservedObject</code> or <code>@EnvironmentObject</code> but the owner of the data should always create the data object with <code>@StateObject</code>.</p>
<hr>
<p>For a great diagram showing what data object type to use where, check out this image from <a href="https://twitter.com/chriseidhof/status/1280433133813456896">Chris Edihof</a> - thanks Chris!</p>
<p><img src="/images/dataflow.png" alt="Data flow"></p>
<p>If you read this article before November 18th 2019, please check out <a href="/post/2019/swiftui-data-flow/#observable2">ObservableObject &amp; @ObservedObject - Part 2</a> again as it has gone through several iterations, which are all shown for comparison.</p>
<hr>
<p>At WWDC 2019, some Apple engineers gave a great presentation on <a href="https://developer.apple.com/videos/play/wwdc2019/226/">Data Flow Through SwiftUI</a> and I strongly recommend watching the video. But you need to watch it twice. First watch it so that you can get started, and then, when you feel that this is all way too complicated, watch it again and it will start to click into place. The only real difference between then and now is that BindableObject has become ObservableObject.</p>
<p>I guess I could stop there, but I will be illustrating my ideas with code examples, which I hope will make things clearer. Some of the examples are rather contrived in order to make a point, but the sample code is also sprinkled with other SwiftUI examples which I hope will prove useful.</p>
<p><a href="https://github.com/trozware/swiftui-data-flow/tree/master">Download the sample project from GitHub</a> and open it in Xcode. Go to ContentView.swift and make sure the Canvas is open. Click Resume to make the view appear. Then click the Live Preview button and wait for the view to become active. I recommend clicking the Pin button at the bottom left of the Canvas so that you can investigate the code samples, while still working in the main navigation.</p>
<h2 id="data-flow-options">
  Data Flow Options
  <a href="#data-flow-options" class="h-anchor" aria-hidden="true">#</a>
</h2>
<p>There are 5 ways to specify data in SwiftUI:</p>
<ul>
<li>Property</li>
<li>@State</li>
<li>@Binding</li>
<li>ObservableObject &amp; @ObservedObject</li>
<li>@EnvironmentObject</li>
</ul>
<style>
  img {
    margin: 10px auto;
  }
</style>

<p><img src="/images/ContentView.png" alt="Content View"></p>
<h2 id="property">
  Property
  <a href="#property" class="h-anchor" aria-hidden="true">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Property</span>: View {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Property</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> greeting = <span style="color:#e6db74">&#34;Hello from SwiftUI!&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Using property directly</span>
</span></span><span style="display:flex;"><span>         Text(greeting)
</span></span><span style="display:flex;"><span>             .font(.title)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this example, the <code>greeting</code> property is used in the view. <code>greeting</code> is static, so the view does not need to monitor it for changes. This may seem like a simplistic and obvious example, but separating it out allows for localization or re-usability.</p>
<p>The property could also have been supplied by a parent view and this is a really useful feature of properties. A parent view can have some dynamic data that it can use to set properties in a subview where the subview only needs to display the data statically. This data will change as the parent view changes but the subview will not be able to change the data in the parent view.</p>
<p>And it is important to remember that not everything needs to be set up with one of these new property wrappers.</p>
<h2 id="state">
  @State
  <a href="#state" class="h-anchor" aria-hidden="true">#</a>
</h2>
<p>This is where things start to get very interesting in the SwiftUI world. SwiftUI views are contained in structs, so are non-mutable. Also, the views are re-created every time the data changes, so any properties are re-created then too. By marking a property with the <code>@State</code> property wrapper, you are telling SwiftUI that you want it to keep this data in a separate portion of memory, allow it to be mutated, and preserve the current value during the view refresh.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">UsingState</span>: View {
</span></span><span style="display:flex;"><span>    @State <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> toggleValue = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Using state with 2-way binding</span>
</span></span><span style="display:flex;"><span>         Toggle(isOn: <span style="color:#960050;background-color:#1e0010">$</span>toggleValue) {
</span></span><span style="display:flex;"><span>             Text(<span style="color:#e6db74">&#34;Toggle is </span><span style="color:#e6db74">\(</span><span style="color:#66d9ef">self</span>.toggleValue ? <span style="color:#e6db74">&#34;ON&#34;</span> : <span style="color:#e6db74">&#34;OFF&#34;</span><span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>         .padding(<span style="color:#ae81ff">50</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this example, <code>toggleValue</code> is declared as a <code>Bool</code> with a property wrapper of <code>@State</code>. Inside the <code>Toggle</code>, the <code>isOn</code> value is bound to <code>toggleValue</code> by the leading <code>$</code>. This allows the variable to set the toggle and the toggle to set the variable - 2-way binding.</p>
<p><img src="/images/Toggle.png" alt="Toggle"></p>
<p><code>@State</code> variables are always value types and are usually local to their view, so Apple recommends marking them as <code>private</code>.</p>
<p>And unlike properties, <code>@State</code> variables allow you to have data that is dynamic but it can still be passed to subviews as properties for display.</p>
<h2 id="binding">
  @Binding
  <a href="#binding" class="h-anchor" aria-hidden="true">#</a>
</h2>
<p>One problem with building SwiftUI views is that it is very easy to end up with a gigantic Pyramid of Doom as you embed views within views within views. The solution is to extract subviews, but then you need a way to pass the data to the subview.</p>
<p>This is where <code>@Binding</code> comes in as it allows you to tell a view that the data for a property is actually coming from a parent but that the subview is allowed to change that property and that change will flow back to the parent&rsquo;s data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Numbers</span>: View {
</span></span><span style="display:flex;"><span>    @State <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> stepperValue = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        NumberChooser(stepperValue: <span style="color:#960050;background-color:#1e0010">$</span>stepperValue)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NumberChooser</span>: View {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Using state from parent with 2-way binding</span>
</span></span><span style="display:flex;"><span>    @Binding <span style="color:#66d9ef">var</span> stepperValue: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        ZStack {
</span></span><span style="display:flex;"><span>            VStack {
</span></span><span style="display:flex;"><span>                Stepper(value: <span style="color:#960050;background-color:#1e0010">$</span>stepperValue, <span style="color:#66d9ef">in</span>: <span style="color:#ae81ff">0.</span>..<span style="color:#ae81ff">20</span>) {
</span></span><span style="display:flex;"><span>                    Text(<span style="color:#e6db74">&#34;Value = </span><span style="color:#e6db74">\(</span>stepperValue<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                NumberBlock(stepperValue: stepperValue)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NumberBlock</span>: View {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// As this view never changes the value, there is no need to bind it</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> stepperValue: Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        Image(systemName: <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>stepperValue<span style="color:#e6db74">)</span><span style="color:#e6db74">.square&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this example, I have declared a <code>stepperValue</code> property and marked it with <code>@State</code>.</p>
<p>The interface has been extracted into a subview called <code>NumberChooser</code> and a <code>Binding</code> to the <code>stepperValue</code> property has been passed to <code>NumberChooser</code> using the <code>$</code> prefix, which will ensure that changes to the value can come back. Inside <code>NumberChooser</code> this property is wrapped in the <code>@Binding</code> property wrapper to indicate that it is coming from another source and that changes will be returned.</p>
<p><code>NumberChooser</code> itself has a subview called <code>NumberBlock</code> but it is a display view only and never mutates the value itself, so <code>stepperValue</code> is passed to this subview as a property only, without the <code>$</code> prefix. It will still be updated every time the data changes as it is contained by the view with the <code>@State</code> property.</p>
<p><img src="/images/NumberChooser.png" alt="Number Chooser"></p>
<h2 id="state--binding---part-2">
  @State &amp; @Binding - Part 2
  <a href="#state--binding---part-2" class="h-anchor" aria-hidden="true">#</a>
</h2>
<p>So far, the examples have used primitive data types for the @State properties, but given that <code>@State</code> properties are value types, any struct can be used. In the next example, I use a struct to hold the properties of a pizza order and use a SwiftUI Form to allow selections.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">PizzaView</span>: View {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Using @State for a struct</span>
</span></span><span style="display:flex;"><span>    @State <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> pizza = Pizza()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>            VStack {
</span></span><span style="display:flex;"><span>                Form {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// Using 2-way binding but each component</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// only needs 1 property from the struct</span>
</span></span><span style="display:flex;"><span>                    PizzaNamePicker(selectedPizzaName: <span style="color:#960050;background-color:#1e0010">$</span>pizza.name)
</span></span><span style="display:flex;"><span>                    PizzaSizePicker(selectedPizzaSize: <span style="color:#960050;background-color:#1e0010">$</span>pizza.size)
</span></span><span style="display:flex;"><span>                    PizzaCrustPicker(selectedPizzaCrust: <span style="color:#960050;background-color:#1e0010">$</span>pizza.crust)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Text representation to prove that the</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// subviews are modifying the parent struct</span>
</span></span><span style="display:flex;"><span>                Text(pizza.pizzaSelection)
</span></span><span style="display:flex;"><span>             }
</span></span><span style="display:flex;"><span>            .navigationBarTitle(<span style="color:#e6db74">&#34;Choose Your Pizza&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Each subview gets the property it needs using <code>@Binding</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">PizzaNamePicker</span>: View {
</span></span><span style="display:flex;"><span>    @Binding <span style="color:#66d9ef">var</span> selectedPizzaName: PizzaName
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// see the GitHub project for more details</span>
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>The form consists of 3 subviews - one each for selecting the pizza, size and crust. The Pizza struct holds all three properties, but each subview only needs a <code>Binding</code> to the single property that it controls. The Text view after the Form is to prove that all the selections come back to the parent.</p>
<p><img src="/images/PizzaView.png" alt="Pizza View"></p>
<h2 id="observableobject--observedobject---part-1">
  ObservableObject &amp; @ObservedObject - Part 1
  <a href="#observableobject--observedobject---part-1" class="h-anchor" aria-hidden="true">#</a>
</h2>
<p>These are used if your data model is a class and you want to use reference-based data instead of the struct&rsquo;s value-based system.</p>
<p>To set up a data model to be Observable, it must conform to the <code>ObservableObject</code> protocol and any property that needs to be observed should have the <code>@Published</code> property wrapper. This makes sure that any time this property changes, all the Views that are observing the instance of this data model will be notified to perform the UI updates.</p>
<p>For this example, I have a ColorSet class with six color components that are used to assemble two RGB colors.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ColorSet</span>: ObservableObject {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ObservableObject</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The 6 color components are marked as @Published so any changes</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// get published to the views that are observing</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> foregroundRed = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> foregroundGreen = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> foregroundBlue = <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> backgroundRed = <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> backgroundGreen = <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> backgroundBlue = <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the primary view, I set up an instance of this class as an <code>@ObservedObject</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ColorSetView</span>: View {
</span></span><span style="display:flex;"><span>    @ObservedObject <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> colorSet = ColorSet()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The background of the view and the foreground of a system image are set using these colors. A button presents a sheet with sliders to allow editing these colors. The <code>colorSet</code> is passed to the sheet like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>  .sheet(isPresented: <span style="color:#960050;background-color:#1e0010">$</span>showChooser) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// notice that this does not use $ as the ColorChooser</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// will get a reference to the ColorSet object</span>
</span></span><span style="display:flex;"><span>      ColorChooser(colorSet: <span style="color:#66d9ef">self</span>.colorSet)
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ColorChooser</span>: View {
</span></span><span style="display:flex;"><span>    @ObservedObject <span style="color:#66d9ef">var</span> colorSet: ColorSet
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A sheet is not the ideal way of presenting a view that uses sliders for editing, but I wanted to demonstrate that changing the sliders instantly changes the value of the <code>@ObservedObject</code> for the parent view as well as for the subview. Editing the background color components shows the new background color in the back at the top of the sheet.</p>
<p>The <code>ColorChooser</code> itself uses 2 subviews and they get a reference to the <code>ColorSet</code> in the same manner.</p>
<p><img src="/images/ColorChooser.png" alt="Color Chooser"></p>
<h2 id="a-nameobservable2observableobject--observedobject---part-2a">
  <!-- raw HTML omitted -->ObservableObject &amp; @ObservedObject - Part 2<!-- raw HTML omitted -->
  <a href="#a-nameobservable2observableobject--observedobject---part-2a" class="h-anchor" aria-hidden="true">#</a>
</h2>
<p>This section was that one that caused me the most trouble when writing the example app. I wanted to display a list of data and have each entry link to an editable detail view with the edits flowing back to the parent list.</p>
<p>The initial display of data in a List was straight-forward and I was then able to have the list rows navigate to a detailed view for each entry. The problem was getting the edited data back to the parent List.</p>
<p>The basic data model was an <code>ObservableObject</code> that publishes an array of <code>PersonViewModel</code> objects.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PersonListModel</span>: ObservableObject {
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> persons: [PersonViewModel] = []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchData</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// get data from web ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        DispatchQueue.main.async {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.persons = newData
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since this data is going to trigger a UI update after a background network call, it is important that changes to the <code>@Published</code> property get switched to the main thread.</p>
<p>The <code>PersonViewModel</code> also needs to be <code>Observable</code> with the editable properties marked as <code>@Published</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PersonViewModel</span>: Identifiable, ObservableObject {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Even though this is not observed directly,</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// it must be an ObservableObject for the data flow to work</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> id = UUID()
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> first: String = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> last: String = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> phone: String = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The odd thing was the way that I had to pass the data to the detail view. This is what I tried initially:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>  List {
</span></span><span style="display:flex;"><span>      ForEach(personList.persons) { person <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>          NavigationLink(destination:
</span></span><span style="display:flex;"><span>              PersonDetailView(person: person)
</span></span><span style="display:flex;"><span>          ) {
</span></span><span style="display:flex;"><span>              Text(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>person.first<span style="color:#e6db74">)</span><span style="color:#e6db74"> </span><span style="color:#e6db74">\(</span>person.last<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>And in <code>PersonDetailView</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>    @ObservedObject <span style="color:#66d9ef">var</span> person: PersonViewModel
</span></span></code></pre></div><p>This almost worked. The correct data was passed to the detail view, and the data edits changed the data, but the parent list was never re-drawn. If I changed a record&rsquo;s first name then went back to the list, the change was not displayed. But if I then returned to the detail view for the same record, my edits were there, so I could tell that the data was changing correctly. The problem was how to change it in such a way that the parent view was notified of the change.</p>
<p>Trying to bind <code>person</code> with <code>PersonDetailView(person: $person)</code> gave the error <code>Use of unresolved identifier '$person'</code>, so the <code>ForEach</code> enumeration did not provide a direct connection to the <code>personList</code> object.</p>
<p>The solution I came up with was to switch to enumerating by index in the <code>ForEach</code> and passing a direct member of the parent list&rsquo;s data to the detail view. And switching the <code>PersonDetailView</code> to use <code>@Binding var person: PersonViewModel</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>ForEach(<span style="color:#ae81ff">0</span> ..<span style="color:#f92672">&lt;</span> personList.persons.count, id: <span style="color:#960050;background-color:#1e0010">\</span>.<span style="color:#66d9ef">self</span>) { index <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    NavigationLink(destination:
</span></span><span style="display:flex;"><span>        PersonDetailView(person: <span style="color:#66d9ef">self</span>.<span style="color:#960050;background-color:#1e0010">$</span>personList.persons[index])
</span></span><span style="display:flex;"><span>    ) {
</span></span><span style="display:flex;"><span>        Text(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span><span style="color:#66d9ef">self</span>.personList.persons[index].first<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>          Text(<span style="color:#e6db74">&#34; </span><span style="color:#e6db74">\(</span><span style="color:#66d9ef">self</span>.personList.persons[index].last<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This works but as well as being hard to read, it has one major flaw. The rows in the table are identified by their row number, rather than by anything in the data like the <code>person.id</code>. This can really mess with how SwiftUI handles the List and how it knows which rows have changed and need to be re-rendered. It is important to identify rows by something unique to the data in each row so that SwiftUI knows that you have deleted the row with the ID &ldquo;abcd-1234&rdquo; and not row #7. Because if you delete row ID &ldquo;abcd-1234&rdquo; there is no longer a row ID &ldquo;abcd-1234&rdquo; but if you delete row #7, there is now a different row #7 and anything could happen.</p>
<p><!-- raw HTML omitted --><strong>Update 1:</strong> <a href="https://twitter.com/StewartLynch">@StewartLynch</a> contacted me to suggest a much neater way to pass the person data to the PersonDetailView by using a function to get a <code>Binding&lt;PersonViewModel&gt;</code> for each <code>person</code> being displayed. This worked perfectly and made for a much cleaner looking bit of code. Thanks Stewart.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>ForEach(personList.persons) { person <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    NavigationLink(destination:
</span></span><span style="display:flex;"><span>        PersonDetailView(person: <span style="color:#66d9ef">self</span>.selectedPerson(id: person.id))
</span></span><span style="display:flex;"><span>    ) {
</span></span><span style="display:flex;"><span>        Text(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>person.first<span style="color:#e6db74">)</span><span style="color:#e6db74"> </span><span style="color:#e6db74">\(</span>person.last<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And outside the <code>body</code> declaration:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">selectedPerson</span>(id: UUID) -&gt; Binding&lt;PersonViewModel&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> index = <span style="color:#66d9ef">self</span>.personList.persons.firstIndex(<span style="color:#66d9ef">where</span>: { $0.id == id }) <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        fatalError(<span style="color:#e6db74">&#34;This person does not exist.&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">self</span>.<span style="color:#960050;background-color:#1e0010">$</span>personList.persons[index]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If you want to have a look at Stewart&rsquo;s solution, check out <a href="https://github.com/trozware/swiftui-data-flow/tree/57f48ea28d1e987566398800e74f12e339eac231">this commit on GitHub</a>.</p>
<p><strong>Update 2:</strong> <a href="https://twitter.com/vadimshpakovski">@vadimshpakovski</a> says that creating a binding for every <code>person</code> object is inefficient and that the function to create this binding will slow things down. He suggests using <code>onReceive</code> to react to changes to <code>person</code> and trigger an update of <code>personList</code>. In this case, <code>PersonDetailView</code> uses <code>@ObservedObject var person: PersonViewModel</code>. This also works perfectly.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>  ForEach(personList.persons) { person <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>      NavigationLink(destination:
</span></span><span style="display:flex;"><span>          PersonDetailView(person: person)
</span></span><span style="display:flex;"><span>              .onReceive(person.objectWillChange) { <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>                  <span style="color:#66d9ef">self</span>.personList.objectWillChange.send()
</span></span><span style="display:flex;"><span>              }
</span></span><span style="display:flex;"><span>      ) {
</span></span><span style="display:flex;"><span>          Text(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span>person.first<span style="color:#e6db74">)</span><span style="color:#e6db74"> </span><span style="color:#e6db74">\(</span>person.last<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>If you want to have a look at Vadim&rsquo;s&rsquo;s solution, check out <a href="https://github.com/trozware/swiftui-data-flow/tree/093810bab93a984292c4a7b8bf29316a830e9f50">this commit on GitHub</a>.</p>
<p><strong>Update 3:</strong> More suggestions have come in from the community (thanks to everyone who contributed) and it has been pointed out to me that while Vadim&rsquo;s solution does solve a lot of the issues, it means that the entire <code>ForEach</code> has to be recalculated to check for changes every time a single <code>Person</code> is edited. And it also inserts model management code into the view code, which is not great.</p>
<p>So my next attempt goes back to using <code>@Binding var person: PersonViewModel</code> in <code>PersonDetailView</code> but instead of <code>PersonListModel</code> having an array of <code>PersonViewModels</code>, it has an array of <code>UUIDs</code> and a dictionary of <code>UUID: PersonListModel</code>. The benefit of this is that the UUIDs can be used in the <code>ForEach</code> as they are unique to each row, and the dictionary can be used to provide a Binding to the <code>person</code> for each <code>UUID</code>.</p>
<p>This removes the problem of my original solution by identifying each row uniquely, it goes back to Stewart&rsquo;s solution but eliminates the potential slow function to create a binding for the matching person, and eliminates the issue of complete redraws and model management inside views from Vadim&rsquo;s suggestion.</p>
<p>But it was not entirely straight-forward as getting a value from a dictionary by key returns an optional. At first I thought I could use the new <code>default</code> syntax for dictionaries to get a non-optional value for binding but for some reason that couldn&rsquo;t be used to create a <code>Binding</code>.</p>
<p>The answer was to write an extension on Dictionary with a <code>subscript</code> function that returns a non-optional value or gives a fatal error. Since I am in control of the data and set up every UUID with a matching PersonViewModel, this is not dangerous.</p>
<p>So here is what we have now:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PersonListModel</span>: ObservableObject {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Main list view model</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ObservableObject so that updates are detected</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> ids: [UUID] = []
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> persons: [UUID : PersonViewModel] = [:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchData</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// get data from web ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        DispatchQueue.main.async {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> personViewModels = dataArray.map { PersonViewModel(with: $0) }.sorted() {
</span></span><span style="display:flex;"><span>              $0.last <span style="color:#f92672">+</span> $0.first <span style="color:#f92672">&lt;</span> $1.last <span style="color:#f92672">+</span> $1.first
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">self</span>.ids = personViewModels.map { $0.id }
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">self</span>.persons = Dictionary(
</span></span><span style="display:flex;"><span>              uniqueKeysWithValues: personViewModels.map { ($0.id, $0) }
</span></span><span style="display:flex;"><span>          )
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>The incoming data is mapped to a sorted array of <code>PersonViewModels</code> before extracting the UUIDs and creating the dictionary. This means that the UUIDs array is in the correct sort order for use in the <code>ForEach</code>.</p>
<p>Here is the Dictionary extension:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">Dictionary</span> <span style="color:#66d9ef">where</span> Key == UUID, Value == PersonViewModel {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">subscript</span>(unchecked key: Key) -&gt; Value {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">guard</span> <span style="color:#66d9ef">let</span> result = <span style="color:#66d9ef">self</span>[key] <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                fatalError(<span style="color:#e6db74">&#34;This person does not exist.&#34;</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">set</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>[key] = newValue
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And these go together to allow this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>ForEach(personList.ids, id: <span style="color:#960050;background-color:#1e0010">\</span>.<span style="color:#66d9ef">self</span>) { id <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    NavigationLink(
</span></span><span style="display:flex;"><span>        destination: PersonDetailView(person: <span style="color:#66d9ef">self</span>.<span style="color:#960050;background-color:#1e0010">$</span>personList.persons[unchecked: id])
</span></span><span style="display:flex;"><span>    ) {
</span></span><span style="display:flex;"><span>        Text(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">\(</span><span style="color:#66d9ef">self</span>.personList.persons[unchecked: id].first<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>            Text(<span style="color:#e6db74">&#34; </span><span style="color:#e6db74">\(</span><span style="color:#66d9ef">self</span>.personList.persons[unchecked: id].last<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/images/PersonListView.png" alt="Person List View"></p>
<p>This ended up a bit more complicated than my original idea, but I think it is now <em>good</em> SwiftUI, avoiding several problems from the earlier solutions.</p>
<p>Thanks to <a href="https://next.json-generator.com">JSON Generator</a> for the sample data. And if anyone has any other solutions to this problem, I would love to hear it. You can contact me using any of the buttons at the end of this article.</p>
<h2 id="environmentobject">
  @EnvironmentObject
  <a href="#environmentobject" class="h-anchor" aria-hidden="true">#</a>
</h2>
<p>Think of the EnvironmentObject a piece of state that can be used by any view or any descendent of the view once it has been introduced. People who have used React or any of the similar web development technologies will be familiar with the concept of global state and this is similar to that, although not truely global.</p>
<p>You set up a class as an EnvironmentObject model exactly as you would set up an ObservableObject with the same protocol conformance and using the <code>@Published</code> property wrapper to mark properties whose changes will trigger UI updates. Here is a very simple example with just one property.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UserSettings</span>: ObservableObject {
</span></span><span style="display:flex;"><span>    @Published <span style="color:#66d9ef">var</span> isLoggedIn: Bool = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="/images/NestedViews.png" alt="Nested Views"></p>
<p>In this example, the yellow view is the parent view - the different views have different brightly colored backgrounds to make them easy to distinguish. The yellow view has access to the <code>UserSettings</code> like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NestingViews</span>: View {
</span></span><span style="display:flex;"><span>    @EnvironmentObject <span style="color:#66d9ef">var</span> userSettings: UserSettings
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        ZStack {
</span></span><span style="display:flex;"><span>            Color.yellow.edgesIgnoringSafeArea(.all)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            VStack {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// UI omitted for space reasons</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// display first nested view</span>
</span></span><span style="display:flex;"><span>                ChildView()
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>ChildView</code> contained in this parent - the green view - has no need to access this data and so gets no <code>@EnvironmentObject</code> property. But <code>ChildView</code> contains another subview - the blue one. And this <code>GrandChildView</code> does need access to the <code>UserSettings</code> so it has the exact same <code>@EnvironmentObject var userSettings: UserSettings</code> property as the parent view.</p>
<p>If this was using <code>@ObservedObject</code> the data would have to be passed through every view in an un-broken chain, even though <code>ChildView</code> did not need this data. By using <code>@EnvironmentObject</code> the chain can be broken, but any view that needs to, can access and mutate this data. In the example, both the yellow and the blue views display and edit the same data with updates happening in both when either button is pressed.</p>
<p>One key thing to remember about previewing <code>@EnvironmentObject</code> in the Canvas is that every view that uses it, or that contains a view that uses it, needs to be supplied with the <code>ObservableObject</code> in the preview using <code>.environmentObject()</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NestingViews_Previews</span>: PreviewProvider {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> previews: some View {
</span></span><span style="display:flex;"><span>        NestingViews()
</span></span><span style="display:flex;"><span>            .environmentObject(UserSettings())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the app itself, only the first view to access the <code>@EnvironmentObject</code> needs it set. In this example, it is done in the <code>NavigationLink</code> that goes to the <code>NestingViews</code> example. The <code>.environmentObject</code> can be provided to the root view in the <code>SceneDelegate</code> if the root view needs it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>    NavigationLink(destination: NestingViews().environmentObject(UserSettings())) {
</span></span><span style="display:flex;"><span>        ListContents(title: <span style="color:#e6db74">&#34;@EnvironmentObject&#34;</span>, imageNumber: <span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="summary">
  Summary
  <a href="#summary" class="h-anchor" aria-hidden="true">#</a>
</h2>
<p>Or What Should I Use When?</p>
<ul>
<li>For value-based data models or data primitives, use <code>@State</code>.</li>
<li>For reference-based data use <code>ObservableObject</code>.</li>
<li>For data needed by a lot of views in your app, use <code>@EnvironmentObject</code>.</li>
<li>Use <code>@Binding</code> or <code>@ObservedObject</code> to pass data to a view that can mutate it.</li>
</ul>
<p>And one final tip: while creating a view from scratch, use <code>@State</code> with sample, hard-coded data. Once you have the interface you want, then change it to use real data.</p>
<p>I am sure people will develop their own theories and their own ways of using SwiftUI, but those are the guidelines that I intend to follow for now. If you have different views and would like to discuss them, please contact me.</p></div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <a class="btn next" href="https://troz.net/post/2021/swiftui_mac_menus/"
        > SwifUI Mac Menus</a
      >
       
      <a class="btn previous" href="https://troz.net/post/2020/crossfix/"
        >Crossfix </a
      >
      
    </div>
  </div>
  
</div>

      </div>

      
        <link rel="stylesheet" href="/css/footer.css" />

<footer class="footer">
  <div class="footer__inner">
    <div class="social_footer">
      <a
        id="email-Link"
        class="mailtoui"
        href="mailto:sarah@troz.net"
        aria-label="Email me"
        ><img src="/icons/envelope.svg" alt=""
      /></a>
      
      <a
        rel="me"
        href="https://mastodon.social/@troz"
        aria-label="Follow me on Mastodon"
        ><img src="/icons/mastodon.png" alt=""
      /></a>

      <a href="https://linktr.ee/trozware" aria-label="Check out all my links"
        ><img src="/icons/tree.svg" alt=""
      /></a>

      <a
        href="https://github.com/trozware"
        aria-label="Look at my code on Github"
        ><img src="/icons/github.svg" alt=""
      /></a>

      <a
        href="https://stackoverflow.com/users/1082632"
        aria-label="Check out my Stack Overflow profile"
        ><img src="/icons/stack-overflow.svg" alt=""
      /></a>

      <a href="https://troz.net/index.xml" aria-label="Subscribe to my RSS feed"
        ><img src="/icons/rss.svg" alt=""
      /></a>
      <a
        href="https://troz.net/feed.json"
        aria-label="Subscribe to my JSON feed"
        ><img src="/icons/json.png" alt=""
      /></a>

      <a href="https://dev.to/trozware" aria-label="Check out my DEV profile">
        <img
          src="/icons/dev-badge.svg"
          alt=""
          alt="TrozWare's DEV Profile"
          style="height: 37px; margin-top: -3px"
          height="40"
          width="40"
        />
      </a>

      <a
        href="https://ko-fi.com/H2H3BU7SI"
        target="_blank"
        aria-label="Buy me a coffee"
        ><img
          height="36"
          style="border: 0px; height: 36px; width: unset"
          src="https://cdn.ko-fi.com/cdn/kofi1.png?v=3"
          border="0"
          alt="Buy Me a Coffee at ko-fi.com"
      /></a>
    </div>
  </div>

  <div class="footer__inner">
    <div class="copyright">
      
      <span> 2012 - 2024 Sarah Reichelt</span>
      
      <span
        ><a href="http://gohugo.io">Hugo</a> theme created by
        <a href="https://twitter.com/panr">panr</a> 2018</span
      >
    </div>
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


<script src="https://cdn.jsdelivr.net/npm/mailtoui@latest/dist/mailtoui-min.js"></script>



<script src="/quicklink.js"></script>

<script>
  window.addEventListener('load', () => {
    quicklink()
  })
</script>


      
    </div>

    
  </body>
</html>
