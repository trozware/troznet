<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>JSON Parsing in Swift 4 :: TrozWare</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content=""/>
<meta name="keywords" content="[Swift Apple macOS iOS Apple Watch]"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://troz.net/post/2017/json-parsing-in-swift-4/" />


<link rel="stylesheet" href="/assets/style.css">
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="/assets/style.css">




<link rel="apple-touch-icon-precomposed" sizes="144x144" href="img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/img/favicon.png">


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="JSON Parsing in Swift 4 :: TrozWare — " />
<meta name="twitter:description" content="Updated: 3rd September 2017.
 Checked syntax using Xcode 9.0 beta 6. Added section on allowing for nulls.  Since JSON has become the de facto standard for data transfers around the internet, there has always been a lot of interest in Swift libraries to parse JSON into Swift classes or structs. Searching for &amp;ldquo;swift json library&amp;rdquo; on GitHub discovers 77 86 repositories. So why are there so many? And what has Swift 4 done to sherlock them all?

" />
<meta name="twitter:site" content="" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image" content="https://troz.net/img/default.jpg">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="JSON Parsing in Swift 4 :: TrozWare — ">
<meta property="og:description" content="" />
<meta property="og:url" content="https://troz.net/post/2017/json-parsing-in-swift-4/" />
<meta property="og:site_name" content="JSON Parsing in Swift 4" />
<meta property="og:image" content="https://troz.net/img/default.jpg">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2017-06-18 00:00:00 &#43;0000 UTC" />







</head>
<body class="dark-theme">
<div class="container">
  <header class="header">
  <span class="header__inner">
    <a href="https://troz.net/" style="text-decoration: none;">
  <div class="logo">
    
      <span class="logo__mark">></span>
      <span class="logo__text">TrozWare</span>
      <span class="logo__cursor"></span>
    
  </div>
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner">
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/apps/">Apps</a></li>
    
      <li><a href="/post/">Archives</a></li>
    
      <li><a href="/tags/">Tags</a></li>
    
      <li><a href="/contact/">Contact</a></li>
    
  </ul>
</nav>
        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>        
        </span>
      
      <span class="theme-toggle">
        <svg class="bulb-off" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="24" height="24"/>
  <path d="M4 19C4 19.55 4.45 20 5 20H9C9.55 20 10 19.55 10 19V18H4V19ZM7 0C3.14 0 0 3.14 0 7C0 9.38 1.19 11.47 3 12.74V15C3 15.55 3.45 16 4 16H10C10.55 16 11 15.55 11 15V12.74C12.81 11.47 14 9.38 14 7C14 3.14 10.86 0 7 0ZM9.85 11.1L9 11.7V14H5V11.7L4.15 11.1C2.8 10.16 2 8.63 2 7C2 4.24 4.24 2 7 2C9.76 2 12 4.24 12 7C12 8.63 11.2 10.16 9.85 11.1Z" transform="translate(5 2)" fill="black"/>
</svg>

<svg class="bulb-on" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="24" height="24"/>
  <path class="bulb-on__base" d="M4 19C4 19.55 4.45 20 5 20H9C9.55 20 10 19.55 10 19V18H4V19Z" transform="translate(5 2)" fill="#a9a9b3" />
  <path class="bulb-on__glass" d="M0 7C0 3.14 3.14 0 7 0C10.86 0 14 3.14 14 7C14 9.38 12.81 11.47 11 12.74V15C11 15.55 10.55 16 10 16H4C3.45 16 3 15.55 3 15V12.74C1.19 11.47 0 9.38 0 7Z" transform="translate(5 2)" fill="#a9a9b3" />
</svg>
  
      </span>
    </span>
  </span>
</header>


  <div class="content">
    
<div class="post">
  <h2 class="post-title"><a href="https://troz.net/post/2017/json-parsing-in-swift-4/">JSON Parsing in Swift 4</a></h2>
  <div class="post-meta">
    <span class="post-date">
      18 Jun 2017
    </span>
    <span class="more-meta"> 2682 words, </span>
    <span class="more-meta"> 13 minute read</span>
  </div>

  
  <span class="post-tags">
    
    #<a href="https://troz.net/tags/swift">swift</a>&nbsp;
    
    #<a href="https://troz.net/tags/json">json</a>&nbsp;
    
    #<a href="https://troz.net/tags/learning-swift">learning swift</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    <p><strong>Updated:</strong> 3rd September 2017.</p>

<ul>
<li>Checked syntax using Xcode 9.0 beta 6.</li>
<li>Added section on <a href="#nulls">allowing for nulls</a>.</li>
</ul>

<hr />

<p>Since <strong>JSON</strong> has become the de facto standard for data transfers around the
internet, there has always been a lot of interest in Swift libraries to parse
JSON into Swift classes or structs. Searching for &ldquo;swift json library&rdquo; on
<a href="https://github.com/search?q=swift+json+library">GitHub</a> discovers <s>77</s> 86 repositories. So why are there so many? And
what has Swift 4 done to <em>sherlock</em> them all?</p>

<p></p>

<p>The problem has always been converting loosely typed JSON to strictly typed
Swift which involves a lot of type casting, checking, optionals etc. Swift has
always provided access to the Objective-C methods for converting JSON to and
from NSData, NSDictionary and NSArray. (These are now called Data, Dictionary
and Array, but those labels are so universal, that I sometimes feel a more
specific nomenclature would be useful. Have you tried doing a search for
&lsquo;Data&rsquo;?)</p>

<p>For sample data, I am using <a href="https://jsonplaceholder.typicode.com/users">https://jsonplaceholder.typicode.com/users</a> which
returns 10 user objects in this format:</p>

<pre><code class="language-json">{
  &quot;id&quot;: 1,
  &quot;name&quot;: &quot;Leanne Graham&quot;,
  &quot;username&quot;: &quot;Bret&quot;,
  &quot;email&quot;: &quot;Sincere@april.biz&quot;,
  &quot;address&quot;: {
    &quot;street&quot;: &quot;Kulas Light&quot;,
    &quot;suite&quot;: &quot;Apt. 556&quot;,
    &quot;city&quot;: &quot;Gwenborough&quot;,
    &quot;zipcode&quot;: &quot;92998-3874&quot;,
    &quot;geo&quot;: {
      &quot;lat&quot;: &quot;-37.3159&quot;,
      &quot;lng&quot;: &quot;81.1496&quot;
    }
  },
  &quot;phone&quot;: &quot;1-770-736-8031 x56442&quot;,
  &quot;website&quot;: &quot;hildegard.org&quot;,
  &quot;company&quot;: {
    &quot;name&quot;: &quot;Romaguera-Crona&quot;,
    &quot;catchPhrase&quot;: &quot;Multi-layered client-server neural-net&quot;,
    &quot;bs&quot;: &quot;harness real-time e-markets&quot;
  }
}
</code></pre>

<p>The goal will be to convert this to an instance of this matching Swift struct:</p>

<pre><code class="language-swift">struct User {
    let id: Int
    let name: String
    let username: String
    let email: String
    let phone: String
    let website: String
    let address: Address
    let company: Company

    struct Address {
        let street: String
        let suite: String
        let city: String
        let zipcode: String
        let geo: Coordinates

        struct Coordinates {
            let lat: Double
            let lng: Double
        }
    }

    struct Company {
        let name: String
        let catchPhrase: String
        let bs: String
    }
}
</code></pre>

<p>The first thing to note is that the Swift struct (and its embedded structs) use
multiple different types: Int, String, Double, Address, Coordinates, Company.
The JSON data only has strings and numbers and even then, some of the numbers
are really strings - look at the lat &amp; lng entries. So converting from JSON to a
struct and back again has always been problematic, but let&rsquo;s give it a go using
built-in Swift 3 processing with no external libraries.</p>

<h2 id="decoding-in-swift-3">Decoding in Swift 3</h2>

<p>You can insert this into a playground or <a href="https://github.com/trozware/json">download my playground</a> and check
out the Swift 3 JSON page:</p>

<pre><code class="language-swift">import Foundation

let sampleDataAddress = &quot;https://jsonplaceholder.typicode.com/users&quot;
let url = URL(string: sampleDataAddress)!
let jsonData = try! Data(contentsOf: url)

struct User {
    let id: Int
    let name: String
    let username: String
    let email: String
    let phone: String
    let website: String
    let address: Address
    let company: Company

    init?(dict: [String: Any]) {
        guard
            let id = dict[&quot;id&quot;] as? Int,
            let name = dict[&quot;name&quot;] as? String,
            let username = dict[&quot;username&quot;] as? String,
            let email = dict[&quot;email&quot;] as? String,
            let phone = dict[&quot;phone&quot;] as? String,
            let website = dict[&quot;website&quot;] as? String,
            let addressDict = dict[&quot;address&quot;] as? [String: Any],
            let address = Address(dict: addressDict),
            let companyDict = dict[&quot;company&quot;] as? [String: Any],
            let company = Company(dict: companyDict)
            else {
                return nil
        }

        self.id = id
        self.name = name
        self.username = username
        self.email = email
        self.phone = phone
        self.website = website
        self.address = address
        self.company = company
    }

    struct Address {
        let street: String
        let suite: String
        let city: String
        let zipcode: String
        let geo: Coordinates

        init?(dict: [String: Any]) {
            guard
                let street = dict[&quot;street&quot;] as? String,
                let suite = dict[&quot;suite&quot;] as? String,
                let city = dict[&quot;city&quot;] as? String,
                let zipcode = dict[&quot;zipcode&quot;] as? String,
                let geoDict = dict[&quot;geo&quot;] as? [String: Any],
                let geo = Coordinates(dict: geoDict) else {
                    return nil
            }

            self.street = street
            self.suite = suite
            self.city = city
            self.zipcode = zipcode
            self.geo = geo
        }

        struct Coordinates {
            let lat: Double
            let lng: Double

            init?(dict: [String: Any]) {
                guard
                    let latString = dict[&quot;lat&quot;] as? String,
                    let lat = Double(latString),
                    let lngString = dict[&quot;lng&quot;] as? String,
                    let lng = Double(lngString) else {
                        return nil
                }
                self.lat = lat
                self.lng = lng
            }
        }
    }

    struct Company {
        let name: String
        let catchPhrase: String
        let bs: String

        init?(dict: [String: Any]) {
            guard
                let name = dict[&quot;name&quot;] as? String,
                let catchPhrase = dict[&quot;catchPhrase&quot;] as? String,
                let bs = dict[&quot;bs&quot;] as? String else {
                    return nil
            }

            self.name = name
            self.catchPhrase = catchPhrase
            self.bs = bs
        }
    }
}

if let json = try? JSONSerialization.jsonObject(with: jsonData, options: []) {
    if let jsonArray = json as? [[String: Any]] {
        let users = jsonArray.flatMap {
            User(dict: $0)
        }
        users.count
        dump(users.first)
    }
}
</code></pre>

<p>I don&rsquo;t actually expect you to go through all this code in detail, but I
included it here to make it obvious how verbose this method is.</p>

<p>The first 3 lines get the data, and I have force-unwrapped the URL and the Data
which I would not do in a production app but which is OK while testing in a
playground. Then there is a declaration of the Users struct with all its sub
structs. Each one has a failable init that tries to parse the JSON dictionary
and returns nil if the data doesn&rsquo;t match, by way of a lengthy set of guard
statements. The basic layout of each struct is the same but it is very verbose.
And as an extra step, the lat and lng properties need to be converted from
Strings to Doubles.</p>

<p>I have to confess that it took quite come time to get this right &hellip; lots of
guard statements to check that the data can be converted to the required types
which meant that any typos produced an empty array. The sub-structs have to be
extracted from the JSON as Dictionaries and then initialised by themselves.</p>

<h2 id="decoding-in-swift-4">Decoding in Swift 4</h2>

<p>So this works, and I get an array of Users objects. But it isn&rsquo;t pretty and it
takes a lot of code to do the processing. So now I am going to move on to doing
this in Swift 4. I am using Xcode 9.0 beta 6 (9M214v) so if you have a later
version, you may need to adapt to any changes.</p>

<pre><code class="language-swift">struct User: Codable {
    let id: Int
    let name: String
    let username: String
    let email: String
    let phone: String
    let website: String
    let address: Address
    let company: Company

    struct Address: Codable {
        let street: String
        let suite: String
        let city: String
        let zipcode: String
        let geo: Coordinates

        struct Coordinates: Codable {
            let lat: String
            let lng: String
        }
    }

    struct Company: Codable {
        let name: String
        let catchPhrase: String
        let bs: String
    }
}

let jsonDecoder = JSONDecoder()
let users = try? jsonDecoder.decode(Array&lt;User&gt;.self,
                                    from: jsonData)
</code></pre>

<p>Ignoring the complexities of converting latitude and longitude to Doubles, I get
vastly simpler code. I declare all the structs as conforming to the <code>Codable</code>
protocol and then I can remove all the init methods and just let <code>JSONDecoder</code>
do its magic. I just have to tell it what data type to expect - in this case an
Array of Users. I don&rsquo;t have to worry about the initial conversion of the JSON
data to a Dictionary or looping through the elements using flatMap.</p>

<p><em>In the playground, I used a do&hellip;catch structure to check the result of the
decode function, but I have used try? here to keep the code short.</em></p>

<h2 id="changing-data-types">Changing data types</h2>

<p>The lat &amp; lng coordinates are stored in the JSON as Strings, but need to be
converted to Doubles for the Swift struct.</p>

<p>This requires a custom init method for the Coordinates struct to do the
conversion from String to Double.</p>

<p>So here is the complete code for Swift 4 - again, if you don&rsquo;t want to create
your own playground, you can <a href="https://github.com/trozware/json">use mine</a>, this time looking at the Swift 4
JSON page:</p>

<pre><code class="language-swift">import Foundation

let sampleDataAddress = &quot;https://jsonplaceholder.typicode.com/users&quot;
let url = URL(string: sampleDataAddress)!
let jsonData = try! Data(contentsOf: url)

struct User: Codable {
    let id: Int
    let name: String
    let username: String
    let email: String
    let phone: String
    let website: String
    let address: Address
    let company: Company

    struct Address: Codable {
        let street: String
        let suite: String
        let city: String
        let zipcode: String
        let geo: Coordinates

        struct Coordinates: Codable {
            let lat: Double
            let lng: Double

            init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                let latString = try values.decode(String.self, forKey: .lat)
                let lngString = try values.decode(String.self, forKey: .lng)
                lat = Double(latString) ?? 0
                lng = Double(lngString) ?? 0
            }
        }
    }

    struct Company: Codable {
        let name: String
        let catchPhrase: String
        let bs: String
    }
}

let jsonDecoder = JSONDecoder()
let users = try? jsonDecoder.decode(Array&lt;User&gt;.self, from: jsonData)

users?.count
dump(users?.first)
</code></pre>

<p>For comparative purposes, I counted the lines of code in each, removing the
common boiler plate of the top of each and the two lines for displaying the
results in the playground. I also removed the blank lines which I always use a
lot in my code for readability but which are not relevant when comparing code
efficiency:</p>

<table>
<thead>
<tr>
<th>Version</th>
<th align="right">Lines</th>
<th align="right">Lines if lat &amp; lng are Strings</th>
</tr>
</thead>

<tbody>
<tr>
<td>Swift 3</td>
<td align="right">95</td>
<td align="right">93</td>
</tr>

<tr>
<td>Swift 4</td>
<td align="right">35</td>
<td align="right">28</td>
</tr>
</tbody>
</table>

<h2 id="encoding">Encoding</h2>

<p>Encoding back to JSON is very similar. In the Swift 3 version, I would have
written a method for each struct that created a Dictionary and then used
JSONSerialization to convert the Dictionary back to JSON. This is very verbose
and tedious to write so I am not going to bother to demonstrate it here.</p>

<p>But in Swift 4, this is even easier than decoding. Add this code to the end of
your Swift 4 JSON playground or playground page:</p>

<pre><code class="language-swift">if let users = users {
    let jsonEncoder = JSONEncoder()
    jsonEncoder.outputFormatting = .prettyPrinted

    if let backToJson = try? jsonEncoder.encode(users) {
        if let jsonString = String(data: backToJson, encoding: .utf8) {
            print(jsonString)
        }
    }
}
</code></pre>

<p>The <code>JSONEncoder</code> returns Data and I have converted that to a String for
checking. I set JSONEncoder&rsquo;s outputFormatting property to .prettyPrinted get a
more readable String.</p>

<p>Notice how the encoded data is not quite the same as I received because the lat
&amp; lng properties are now Doubles. In a production app, if I needed to be able to
convert back to JSON, I probably would have left them as Strings so as to enable
data transfer in both directions. I would add computed properties to the struct
to convert these Strings to Doubles as I needed them.</p>

<h2 id="advanced-decoding">Advanced Decoding</h2>

<p>Now that we have the basics, I want to look at three more features: changing
property names, date handling and allowing for nulls.</p>

<h2 id="changing-property-names">Changing Property Names</h2>

<p>In these examples I used exactly the same names for the properties as were used
in the JSON. In the Swift 3 version, it would have been easy to change the
property names, since the data for each property was being extracted manually.
In Swift 4, if you want the decoder to change names, you have to tell it what
you want.</p>

<p>Make a new playground or playground page and replace the contents with this - or
go to the Swift 4 Extras page on <a href="https://github.com/trozware/json">my playground</a>:</p>

<pre><code class="language-swift">import Foundation

let jsonString = &quot;&quot;&quot;
{
&quot;name1&quot;: &quot;Jane&quot;,
&quot;name2&quot;: &quot;Smith&quot;
}
&quot;&quot;&quot;
let jsonData = jsonString.data(using: .utf8)!

struct Person: Codable {
    let firstName: String
    let lastName: String
}

let jsonDecoder = JSONDecoder()
let person = try? jsonDecoder.decode(Person.self, from: jsonData)
dump(person)
</code></pre>

<p>This uses the new multi-line literals in Swift 4 to assemble the JSON string
which is amazingly useful as it allows quotes to be embedded in the string
without having to escape them. As you can see, the JSON property names are not
very helpful, so I want to change them in my Person struct. At the moment,
<code>person</code> is nil because I have not given the decoder any clues to help it
translate the names. To do that, I have to add a CodingKeys enum to the Person
struct and it tells the decoder what names in the JSON match up to what
properties in the struct.</p>

<pre><code class="language-swift">struct Person: Codable {
    let firstName: String
    let lastName: String

    enum CodingKeys: String, CodingKey {
        case firstName = &quot;name1&quot;
        case lastName = &quot;name2&quot;
    }
}
</code></pre>

<p>And that&rsquo;s all I have to do. Now the JSON is correctly converted to a Person. As
an exercise, use JSONEncoder to get back to JSON from the Person. You will see
that the JSON correctly names the elements using &ldquo;name1&rdquo; and &ldquo;name2&rdquo;.</p>

<h2 id="date-handling">Date Handling</h2>

<p>Next let&rsquo;s look at dates - add this code to the playground:</p>

<pre><code class="language-swift">let jsonString2 = &quot;&quot;&quot;
{
&quot;name&quot;: &quot;My New Project&quot;,
&quot;created&quot;: &quot;2017-06-18T06:28:25Z&quot;
}
&quot;&quot;&quot;
let jsonData2 = jsonString2.data(using: .utf8)!

struct Project: Codable {
    let name: String
    let created: Date
}

let jsonDecoder2 = JSONDecoder()
let project = try? jsonDecoder2.decode(Project.self, from: jsonData2)

dump(project)
</code></pre>

<p>When this runs, <code>project</code> is nil because the decoder has no idea how to get from
the String &ldquo;2017-06-18T06:28:25Z&rdquo; to a Date object. Add this line after creating
<code>jsonDecoder2</code>:</p>

<pre><code class="language-swift">jsonDecoder2.dateDecodingStrategy = .iso8601
</code></pre>

<p>Now the date can be converted and an instance of the Project struct will be
created.</p>

<p>And to get back to the JSON, converting the Date back to ISO8601 format:</p>

<pre><code class="language-swift">let jsonEncoder = JSONEncoder()
jsonEncoder.dateEncodingStrategy = .iso8601

if let backToJson = try? jsonEncoder.encode(project) {
    if let jsonString = String(data: backToJson, encoding: .utf8) {
        print(jsonString)
    }
}
</code></pre>

<p><a name ="nulls"></a></p>

<h2 id="allowing-for-nulls">Allowing For Nulls</h2>

<p>JSON data will often include <strong>null</strong> where there is no value for a particular
property name. When using JSONDecoder or JSONEncoder, this can be allowed for by
using Optionals. If you are not clear about Optionals, have a look at my
previous article: <a href="/post/2016-02-12-learning-swift-optionals/">Learning Swift - Optionals</a>.</p>

<p>The crucial step is to declare the properties of the Swift object as optionals
if you think they could get a null value.</p>

<pre><code class="language-swift">struct Role: Codable {
    let firstName: String
    let lastName: String
    let nickName: String?
}

let jsonStringWithNulls = &quot;&quot;&quot;
[
    {
        &quot;firstName&quot;: &quot;Sally&quot;,
        &quot;lastName&quot;: &quot;Sparrow&quot;,
        &quot;nickName&quot;: null
    },
    {
        &quot;firstName&quot;: &quot;Doctor&quot;,
        &quot;lastName&quot;: &quot;Who&quot;,
        &quot;nickName&quot;: &quot;The Doctor&quot;
    }
]
&quot;&quot;&quot;
let jsonDataWithNulls = jsonStringWithNulls.data(using: .utf8)!

let jsonDecoder3 = JSONDecoder()
let roles = try? jsonDecoder3.decode(Array&lt;Role&gt;.self, from: jsonDataWithNulls)
dump(roles)
</code></pre>

<p>In this example (which you can find in the Swift 4 Extras page on <a href="https://github.com/trozware/json">my
playground</a>), I have declared a struct called Role with 3 String properties.
The 3rd String - nickName - is an Optional so it may be a String or it may be
nil.</p>

<p>The JSON contains 2 elements - one has a nickName value and the other has it as
null. Because the matching property in the Swift struct is an optional, this
works as expected and the nickName property for Sally Sparrow is decoded as nil.
If you remove the question mark to make nickName non-optional, the decoding will
fail.</p>

<p>Going back to JSON from a Swift object with optionals works much the same except
that it does not specifically mark items as null, it just leaves them out.</p>

<pre><code class="language-swift">let jsonEncoder2 = JSONEncoder()
jsonEncoder2.outputFormatting = .prettyPrinted

if let backToJsonWithNulls = try? jsonEncoder2.encode(roles) {
    if let jsonString = String(data: backToJsonWithNulls, encoding: .utf8) {
        print(jsonString)
    }
}
</code></pre>

<h2 id="property-lists">Property Lists</h2>

<p>As well as JSONDecoder and JSONEncoder, Swift 4 has introduced
PropertyListDecoder and PropertyListEncoder, so let&rsquo;s take a quick look at that.</p>

<p>Add this to the bottom of the last playground as it uses the Project struct and
data:</p>

<pre><code class="language-swift">let plistEncoder = PropertyListEncoder()
plistEncoder.outputFormat = .xml
if let plist = try? plistEncoder.encode(project) {
    if let plistString = String(data: plist, encoding: .utf8) {
        print(plistString)
    }

    let plistDecoder = PropertyListDecoder()
    let project2 = try? plistDecoder.decode(Project.self, from: plist)

    dump(project2)
}
</code></pre>

<p>I don&rsquo;t see this is being quite as useful as the JSON Encoding &amp; Decoding, but I
mention it here for completeness.</p>

<h2 id="codable">Codable</h2>

<p>In all the Swift 4 examples above, I set the structs to conform to <code>Codable</code>.
Reading Apple&rsquo;s docs, I see that <code>Codable</code> is actually a typealias referring to
2 separate protocols:</p>

<pre><code class="language-Swift">typealias Codable = Decodable &amp; Encodable
</code></pre>

<p>If you only need to convert data one way, it will be more efficient to set your
struct or class as confirming to only one of these protocols. For example, if
you download JSON data from an API but never need to send it back, just conform
to Decodable to transform the JSON data into your data structure.</p>

<p>Much more information can be found in the <a href="https://developer.apple.com/documentation/swift/encoding_decoding_and_serialization">Apple documentation</a>.</p>
  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <a class="btn next" href="https://troz.net/post/2017/moving-to-hugo/">← Moving to Hugo</a>
      
      
      <a class="btn previous" href="https://troz.net/post/2017/posting-from-my-new-ipad/">Posting from my new iPad →</a>
      
    </div>
  </div>
  
</div>

  </div>

  
    <link rel="stylesheet" href="/css/footer.css">

<footer class="footer">
  <div class="footer__inner">
    <div class="social_footer">
      <a href="mailto:sarah@troz.net"><img src="/icons/envelope.svg" /></a>
      <a href="https://stackoverflow.com/users/1082632"><img src="/icons/stack-overflow.svg" /></a>
      <a href="https://twitter.com/trozware"><img src="/icons/twitter.svg" /></a>
      <a href="https://github.com/trozware"><img src="/icons/github.svg" /></a>
      <a href="https://troz.net/index.xml"><img src="/icons/rss.svg" /></a>
      <a href="https://troz.net//feed.json"><img src="/icons/json.png" /></a>
    </div>
  </div>

  <div class="footer__inner">
    <div class="copyright">
      
      <span>© 2012 - 2018 Sarah Reichelt</span>
      
      <span><a href="http://gohugo.io">Hugo</a> theme created by <a href="https://twitter.com/panr">panr</a> 2018</span>
    </div>
  </div>
</footer>


  <script src="/assets/main.js"></script>

  <script src="/assets/prism.js"></script>


  
</div>

</body>
</html>
