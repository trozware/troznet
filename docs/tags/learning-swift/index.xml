<rss version="2.0" 
  xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>learning swift on TrozWare</title>
    <link>https://troz.net/tags/learning-swift/</link>
    <description>Recent content in learning swift on TrozWare</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Â© 2012 - 2019 Sarah Reichelt</copyright>
    <lastBuildDate>Sun, 03 Feb 2019 19:48:51 +1000</lastBuildDate>
    
        <atom:link href="https://troz.net/tags/learning-swift/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
<title>Learning Swift  - Tuples</title>
<link>https://troz.net/post/2019/learning-swift-tuples/</link>
<pubDate>Sun, 03 Feb 2019 19:48:51 +1000</pubDate>
      
      <guid>https://troz.net/post/2019/learning-swift-tuples/</guid>
<description>&lt;style&gt;
  img {
    margin: 10px auto;
    border: 0.5rem #dfe7f0 solid;
    border-radius: 0.5rem;
     
  }

  .dark-theme img {
    margin: 10px auto;
    border: 0.5rem #4a4d50 solid;
    border-radius: 0.5rem;
     
  }

  .social_footer img {
    border: none;
    box-shadow: none;
  }
&lt;/style&gt;

&lt;p&gt;I sometimes like to focus on aspects of the Swift language that get less publicity, but that I think are really useful without adding a lot of complexity. This time I am looking at tuples.&lt;/p&gt;

&lt;p&gt;There are many different ways of collecting data together in Swift, but for small amounts of transitory data, I find tuples to be an extremely convenient data structure.&lt;/p&gt;

&lt;h2 id=&#34;what-is-a-tuple&#34;&gt;What is a Tuple?&lt;/h2&gt;

&lt;p&gt;A tuple is basically an array with a pre-determined length and unlike normal Swift arrays, it can hold a mix of data types.&lt;/p&gt;

&lt;p&gt;Here are some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let pair = (&amp;quot;Jessie&amp;quot;, &amp;quot;Woody&amp;quot;)
let coords = (0, 4, -6)
let pet = (type: &amp;quot;cat&amp;quot;, trained: false, age: 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To define a tuple, you enclose the data elements in parentheses - normal brackets, not curly or square. Optionally, the elements can have a label attached as shown in the &lt;code&gt;pet&lt;/code&gt; example.&lt;/p&gt;

&lt;p&gt;Tuples can have any number of components, but if they get too long, a struct might be a better option. &lt;a href=&#34;https://github.com/realm/SwiftLint&#34;&gt;SwiftLint&lt;/a&gt; will complain if you use tuples with more than 3 elements and usually I go along with that.&lt;/p&gt;

&lt;p&gt;There are various ways to access the parts of a tuple. The first way is using index numbers which works but isn&amp;rsquo;t very intuitive and could be hard to decipher when you come back to a project after some time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;print(pair.0)
print(pair.1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next way is if the tuple has used labels for the elements as in the &lt;code&gt;pet&lt;/code&gt; example above:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;print(pet.type)
print(pet.trained)
print(pet.age)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But the way I prefer to use them is by deconstructing the parts into separate variables in a single statement:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let (x, y, z) = coords
print(x, y, z)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The elements of a tuple can be of different types but once a tuple has been defined, that type of each element is fixed, so you still get all the benefits of Swift&amp;rsquo;s type safety.&lt;/p&gt;

&lt;p&gt;Option-clicking on the variable name shows the inferred type of the tuple:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/Tuple_type.png&#34; alt=&#34;The type of a tuple.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Trying to re-assign the tuple or any elements of the tuple will only work if the new assignments match the initial types for each element:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/Tuple_errors.png&#34; alt=&#34;Errors when mutating a tuple.&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;where-could-you-use-a-tuple-and-why&#34;&gt;Where could you use a tuple and why?&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s imagine you have a function that checks a database or web service and comes back with the title of a movie and its rating.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func getMovieInfo() {
  var movieTitle: String
  var rating: Int

  // get the data from somewhere
  // now return both movieTitle and rating
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having got the data, this function needs to return two pieces of data: &lt;code&gt;movieTitle&lt;/code&gt; and &lt;code&gt;rating&lt;/code&gt; - one &lt;code&gt;String&lt;/code&gt; and one &lt;code&gt;Int&lt;/code&gt;. How could this be done?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Array&lt;/strong&gt;: since there are 2 different data types, the array would have to be of type &lt;code&gt;[Any]&lt;/code&gt; or the &lt;code&gt;Int&lt;/code&gt; could be converted to a &lt;code&gt;String&lt;/code&gt; before returning. Neither of these are good options. Using &lt;code&gt;Any&lt;/code&gt; removes the protection of Swift&amp;rsquo;s type safety and converting the &lt;code&gt;Int&lt;/code&gt; to and from a &lt;code&gt;String&lt;/code&gt; may fail, so then you have to deal with optionals.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Dictionary&lt;/strong&gt;: the same arguments hold true. The dictionary would have to be of type &lt;code&gt;[String: Any]&lt;/code&gt; or the rating would have to be converted to a &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Struct or Class&lt;/strong&gt;: either of these would be fine but unless this is a data structure that is going to be re-used, it seems like overkill.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tuple&lt;/strong&gt;: this would get my vote, so let&amp;rsquo;s see how that would work.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func getMovieInfo() -&amp;gt; (String, Int) {
var movieTitle: String
var rating: Int

// get the data from somewhere

return (movieTitle, rating)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Two main things to notice here:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The return type of the function lists the data types of both the elements being returned, enclosed in parentheses.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The returning tuple is created by wrapping the elements inside parentheses, just like in the examples above.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And then in the calling function, you can access the parts of the returned data like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let (returnedMovieTitle, returnedRating) = getMovieInfo()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tuple is being returned and immediately deconstructed to give 2 new variables so accessing the parts of the tuple is easy and type-safe.&lt;/p&gt;

&lt;p&gt;A function returning a tuple can also be configured to use named elements by specifying the names in the return type declaration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func getMovieInfo() -&amp;gt; (name: String, score: Int) {
    var movieTitle: String
    var rating: Int

    // get the data from somewhere

    return (movieTitle, rating)
}

let result = getMovieInfo()
let returnedMovieTitle = result.name
let returnedRating = result.score
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My feeling is that once a tuple is complex enough to need names, you should really consider using a class or a struct, but for returning 2 or 3 chunks of data from a function, this is a very useful technique, espeicialy if the data types are different.&lt;/p&gt;

&lt;h2 id=&#34;looping-through-tuples&#34;&gt;Looping through tuples&lt;/h2&gt;

&lt;p&gt;If you have an array of tuples, looping through the tuples is made very convenient if you use the deconstruction method of accessing the parts.&lt;/p&gt;

&lt;p&gt;As an example, suppose you are dealing with some 3D coordinate system and you want to perform an operation on each location.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let coords_array = [
    (0, 0, 0),
    (0, 1, -3),
    (1, 4, 2),
    (-2, 0, 5),
    (5, 2, 4)
]

for (x, y, z) in coords_array {
    let distanceFromOrigin = abs(x) + abs(y) + abs(z)
    print(distanceForOrigin)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can deconstruct the tuple each time through the loop, assigning temporary variables so you can act on them.&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h2&gt;

&lt;p&gt;So those are the basics of tuples: how to create them, how to use them and where they might be useful. My main use is as a light-weight alternative to a struct for returning multi-part data from a function. But hopefully after reading this article, they have become another tool in your Swift tool belt that you can consider using in certain circumstances.&lt;/p&gt;

&lt;h3 id=&#34;that-leaves-only-one-important-question-how-do-you-pronounce-tuple&#34;&gt;That leaves only one important question: how do you pronounce &amp;lsquo;tuple&amp;rsquo;?&lt;/h3&gt;

&lt;p&gt;I have heard two variations: &amp;lsquo;toople&amp;rsquo; using a long U as in universe or &amp;lsquo;tupple&amp;rsquo; using a short U as in cup. There does not appear to be any strict geographical differentiation, so take your pick. I prefer &amp;lsquo;toople&amp;rsquo; myself, but if somebody says &amp;lsquo;tupple&amp;rsquo;, I know what they mean.&lt;/p&gt;</description>
</item>
    
    <item>
<title>Functional Programming in Swift</title>
<link>https://troz.net/post/2018/functional-programming/</link>
<pubDate>Thu, 14 Jun 2018 14:18:53 +1000</pubDate>
      
      <guid>https://troz.net/post/2018/functional-programming/</guid>
<description>&lt;p&gt;What is Functional Programming and how can we use it in Swift?&lt;/p&gt;

&lt;p&gt;Search online for any definition of functional programming and you will find many different definitions, few of which are practically helpful. I have no claim to be an expert, but as a Swift enthusiast, this is what I have distilled out of the morass.&lt;/p&gt;

&lt;h2 id=&#34;what-is-functional-programming&#34;&gt;What is Functional Programming?&lt;/h2&gt;

&lt;p&gt;Without providing a concrete definition, here are what I see as the 3 main goals of functional programming:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;use pure functions where possible&lt;/li&gt;
&lt;li&gt;avoid mutability where possible&lt;/li&gt;
&lt;li&gt;use functions as the basic building blocks&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So let&amp;rsquo;s go through those one by one and see how they fit into the Swift language.&lt;/p&gt;

&lt;h2 id=&#34;functional-programming-in-swift&#34;&gt;Functional Programming in Swift&lt;/h2&gt;

&lt;p&gt;You can &lt;a href=&#34;https://github.com/trozware/functional-programming&#34;&gt;download a playground containing all these examples from GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;pure-functions&#34;&gt;Pure functions&lt;/h3&gt;

&lt;p&gt;A function is considered pure if it will always produce the same result for the same input, regardless of where it is and what calls it.&lt;/p&gt;

&lt;p&gt;Imagine you are writing a role-playing game and for a given fight, you need to be able to calculate the damage per second caused by a character.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class DamageDealer {

    var damageDone: Int = 0
    var timeTaken: TimeInterval = 0

    func damagePerSecond() -&amp;gt; Double {
        if timeTaken == 0 {
            return 0
        }
        let dps = Double(damageDone) / timeTaken
        if dps &amp;lt; 0 {
            return 0
        }
        return dps
    }

}

let mage = DamageDealer()
mage.damageDone = 32
mage.timeTaken = 10

mage.damagePerSecond()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;damagePerSecond&lt;/code&gt; function takes no parameters but uses the properties of its containing object. This works in this class, but there are 3 big problems:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The function is not transportable - you cannot copy it into another class as it is totally dependent on the structure of the properties in the containing class.&lt;/li&gt;
&lt;li&gt;When calling the function, it is not clear what data it is going to use.&lt;/li&gt;
&lt;li&gt;This function is difficult to test as calling the function with the same parameters (none) will produce different results depending on the setup.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So for a version that uses a pure function, we could replace &lt;code&gt;damagePerSecond()&lt;/code&gt; with this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func damagePerSecondPure(damage: Int, time: TimeInterval) -&amp;gt; Double {
    if time == 0 {
        return 0
    }
    let dps = Double(damage) / time
    if dps &amp;lt; 0 {
        return 0
    }
    return dps
}

mage.damagePerSecondPure(damage: mage.damageDone, time: mage.timeTaken)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Calling the function is now more verbose, but reading the call gives you much more information about what is going to happen. Testing is easy, and the function is completely self-contained so can be copied into any class or struct.&lt;/p&gt;

&lt;h3 id=&#34;avoid-mutability&#34;&gt;Avoid mutability&lt;/h3&gt;

&lt;p&gt;This one has become the poster child of Swift Functional Programming as Swift provides some very convenient ways to avoid mutability.&lt;/p&gt;

&lt;p&gt;The first is &lt;code&gt;let&lt;/code&gt; versus &lt;code&gt;var&lt;/code&gt;. My rule is always to start defining any variable/constant with &lt;code&gt;let&lt;/code&gt; and only changing to &lt;code&gt;var&lt;/code&gt; if the compiler raises an error. In the current versions of Xcode, it will give a warning if you use &lt;code&gt;var&lt;/code&gt; unnecessarily which is great, but I still stick to using &lt;code&gt;let&lt;/code&gt; first.&lt;/p&gt;

&lt;p&gt;The most powerful way Swift lets us avoid mutability with Functional Programming is with &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;filter&#34;&gt;Filter&lt;/h4&gt;

&lt;p&gt;Consider this function that checks possible player names:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func checkPlayerNames(names: [String]) -&amp;gt; [String] {
    var validNames: [String] = []

    for name in names {
        if name.count &amp;gt; 3 &amp;amp;&amp;amp; !name.contains(&amp;quot; &amp;quot;) {
            validNames.append(name)
        }
    }

    return validNames
}

let allNames = [ &amp;quot;Woody&amp;quot;, &amp;quot;Rex&amp;quot;, &amp;quot;Slinky&amp;quot;, &amp;quot;Buzz Lightyear&amp;quot;, &amp;quot;Hamm&amp;quot; ]
let checkedNames = checkPlayerNames(names: allNames)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only names with more than 3 characters and no spaces are considered valid. So this function creates an empty array and then loops through each member of the supplied array and appends any valid names to the new array before returning it.&lt;/p&gt;

&lt;p&gt;This function is a pure function and it works as expected. But the &lt;code&gt;validNames&lt;/code&gt; array is mutable and there is no need for it to be.&lt;/p&gt;

&lt;p&gt;Converting this to avoid mutability, we get:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func checkPlayerNamesUsingFilter(names: [String]) -&amp;gt; [String] {
    let validNames = names.filter { name in
        name.count &amp;gt; 3 &amp;amp;&amp;amp; !name.contains(&amp;quot; &amp;quot;)
    }
    return validNames
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside the &lt;code&gt;filter&lt;/code&gt; closure delimited by the curly braces after the word &lt;code&gt;filter&lt;/code&gt;, (more about closures below), the element in the array being evaluated is stored in the &lt;code&gt;name&lt;/code&gt; constant. The checks are done and this implicitly returns a &lt;code&gt;Bool&lt;/code&gt; - true if the checks pass, false if they do not. If the closure returns true, the name is valid and will be part of the validNames array.&lt;/p&gt;

&lt;p&gt;And if you really want to be concise:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func checkPlayerNamesUsingFilterShort(names: [String]) -&amp;gt; [String] {
    return names.filter { $0.count &amp;gt; 3 &amp;amp;&amp;amp; !$0.contains(&amp;quot; &amp;quot;) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I recommend the first method even if it is a bit more verbose. Storing the result in a constant before returning it makes debugging much easier. Using $0 instead of using a named parameter is convenient, but I prefer not to do this unless the closure is very simple.&lt;/p&gt;

&lt;h4 id=&#34;map&#34;&gt;Map&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;filter&lt;/code&gt; takes an array of objects and returns a sub-array containing every element which returned true for the checks inside the filter body.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; changes the elements in an array and can return an array of the same type or an array of different types.&lt;/p&gt;

&lt;p&gt;Here is a function to square every integer in an array in the old style, using a mutable array to accumulate the result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func squareNumbers(_ numbers: [Int]) -&amp;gt; [Int] {
    var squares: [Int] = []

    for number in numbers {
        squares.append(number * number)
    }

    return squares
}

let numbers = [ 1, 2, 3, 4, 5, 6 ]
squareNumbers(numbers)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And doing the same thing using &lt;code&gt;map&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func squareNumbersUsingMap(_ numbers: [Int]) -&amp;gt; [Int] {
    let squares = numbers.map { $0 * $0 }
    return squares
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the type of the data did not change: integers went in, integers came out.
But &lt;code&gt;map&lt;/code&gt; can change the type as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func squareRoots(_ numbers: [Int]) -&amp;gt; [Double] {
    let roots = numbers.map { number in
        sqrt(Double(number))
    }
    return roots
}

squareRoots(numbers)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there is a final twist to &lt;code&gt;map&lt;/code&gt; that used to be called &lt;code&gt;flatMap&lt;/code&gt; but is now called &lt;code&gt;compactMap&lt;/code&gt; and that allows us to get rid of optionals as we map through an array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func convertStringsToInts(_ strings: [String]) -&amp;gt; [Int] {
    let ints = strings.compactMap { return Int($0) }
    return ints
}

let strings = [ &amp;quot;1&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;0.34&amp;quot;, &amp;quot;65&amp;quot;, &amp;quot;-93&amp;quot;, &amp;quot;4e8&amp;quot; ]
convertStringsToInts(strings)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The conversion of &lt;code&gt;String&lt;/code&gt; to &lt;code&gt;Int&lt;/code&gt; may fail and so returns an optional. If this function had used &lt;code&gt;map&lt;/code&gt; instead of &lt;code&gt;compactMap&lt;/code&gt;, the result would have been an array of optional Ints: &lt;code&gt;[Int?]&lt;/code&gt;. By using &lt;code&gt;compactMap&lt;/code&gt;, every &lt;code&gt;nil&lt;/code&gt; value was dropped and only valid integers are included.&lt;/p&gt;

&lt;h4 id=&#34;reduce&#34;&gt;Reduce&lt;/h4&gt;

&lt;p&gt;The final tool in the immutability toolbox is &lt;code&gt;reduce&lt;/code&gt; and this is one that took me a while to wrap my head around.&lt;/p&gt;

&lt;p&gt;Imagine that you wanted to add up all the integers in an array. Here is a way to do it using a mutable variable and a loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func sumNumbers(_ numbers: [Int]) -&amp;gt; Int {
    var total = 0

    for num in numbers {
        total += num
    }

    return total
}

let numbers = [ 1, 2, 3, 4, 5, 6 ]
sumNumbers(numbers)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I can&amp;rsquo;t use &lt;code&gt;filter&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt; here because I want to end up with a single value after applying some logic to every item in the array. So here is where I use &lt;code&gt;reduce&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func sumNumbersUsingReduce(_ numbers: [Int]) -&amp;gt; Int {

    let total = numbers.reduce(0) { (cumulativeTotal, nextValue) in
        return cumulativeTotal + nextValue
    }
    return total
}

sumNumbersUsingReduce(numbers)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;reduce&lt;/code&gt; function takes 2 parameters. The first is the starting value - in this case it is zero. The second paramter is a function (I am using a closure) this in turn takes 2 parameters and here is where it gets complicated. Inside the closure function, the 2 parameters are the current result and the next value from the loop. And what you return from this closure is going to be the new cumulative value which will either be fed back into the loop, or returned as the final result. The first time through the loop, the first parameter will be the initial value as set in the reduce function call.&lt;/p&gt;

&lt;p&gt;To see how this happens, here is a version sprinkled with &lt;code&gt;print&lt;/code&gt; statements showing what happens each time through the loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func sumNumbersReduceDebug(_ numbers: [Int]) -&amp;gt; Int {
    let total = numbers.reduce(0) { (cumulativeTotal, nextValue) in
        print(&amp;quot;cumulativeTotal = \(cumulativeTotal)&amp;quot;)
        print(&amp;quot;nextValue = \(nextValue)&amp;quot;)
        print(&amp;quot;about to return \(cumulativeTotal) + \(nextValue) = \(cumulativeTotal + nextValue) which will become the next culmulative or the final value&amp;quot;)

        return cumulativeTotal + nextValue
    }
    print(&amp;quot;final result = \(total)&amp;quot;)
    return total
}

let shortNumbers = [ 5, 3, 8 ]

sumNumbersReduceDebug(shortNumbers)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This produces a log showing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;cumulativeTotal = 0
nextValue = 5
about to return 0 + 5 = 5 which will become the next culmulative or the final value
cumulativeTotal = 5
nextValue = 3
about to return 5 + 3 = 8 which will become the next culmulative or the final value
cumulativeTotal = 8
nextValue = 8
about to return 8 + 8 = 16 which will become the next culmulative or the final value
final result = 16
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;using-functions-as-building-blocks&#34;&gt;Using functions as building blocks&lt;/h3&gt;

&lt;p&gt;This one is more a matter of style than of any particular programming technique. Basically, keep each function small and break your code into small chunks with obvious naming. This makes your code easier to read, test and debug and it beomes vastly more reusable.&lt;/p&gt;

&lt;p&gt;Consider this totally made-up function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func configureDisplay(for userId: String?) {
    guard let userId = userId else {
        showLoginScreen()
        return
    }

    displayUserData(for: userId)
    let userType = getPermissions(for: userId)

    populateMenus(for: userType)
    loadInitialData(for: userId)

    playSound(.welcome)
}

configureDisplay(for: &amp;quot;abc123&amp;quot;)
configureDisplay(for: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is it easy to read?
Can you work out what it does? Now imagine all that functionality in a single huge function - would that be as good to use?&lt;/p&gt;

&lt;p&gt;As a way of encouraging shorter functions, which leads inevitably to this sort of structured code, I strongly recommend using SwiftLint to check your code. I wrote a &lt;a href=&#34;https://troz.net/post/2018/swiftlint/&#34;&gt;post about this&lt;/a&gt; a while ago which you might find useful.&lt;/p&gt;

&lt;h4 id=&#34;naming&#34;&gt;Naming&lt;/h4&gt;

&lt;p&gt;The other key thing to mention and it is a point that Apple makes very strongly, is to name your functions and their parameters so as to make them as readable as possible from the calling site. You write a function once, but you most likely call it multiple times, so it is the calling site that needs to be really easy to read.&lt;/p&gt;

&lt;p&gt;Returning to the game example, here is a dummy function to show damage caused to a target:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func displayDamage(damage: Int, target: String) {}

displayDamage(damage: 31, target: &amp;quot;Ogre&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is nothing really wrong with the function, but calling it is a bit clunky and doesn&amp;rsquo;t read well with the repeated use of the word &amp;lsquo;damage&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;What about this version?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func display(damage: Int, doneTo target: String) {}

display(damage: 42, doneTo: &amp;quot;Wolf&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are no repeated words in the caller and by using two labels for the second parameter, the calling site can read almost like a sentence, but inside the function, &lt;code&gt;target&lt;/code&gt; is still a more logical name.&lt;/p&gt;

&lt;p&gt;A third alternative is to use an un-named parameter if the naming logic is implicit in the function name itself:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func displayDamage(_ damage: Int, doneTo target: String) {}

displayDamage(12, doneTo: &amp;quot;Orc&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;closures&#34;&gt;Closures&lt;/h2&gt;

&lt;p&gt;As promised above, a very quick explanation of closures, which really deserve their own post&amp;hellip;&lt;/p&gt;

&lt;p&gt;In Swift, as in many languages, functions can be passed as parameters to other functions. As an example, I have set up 2 functions to perform a simple calculation on a given integer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func cube(_ number: Int) -&amp;gt; Int {
    return number * number * number
}
cube(3)

func square(_ number: Int) -&amp;gt; Int {
    return number * number
}
square(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now imagine that you wanted to create a more general function that could call either one of these functions with any number:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func doCalculation(_ number: Int, calculation: (Int) -&amp;gt; Int) -&amp;gt; Int {
    return calculation(number)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;doCalculation&lt;/code&gt; takes 2 parameters. The first one is easy - it is just an integer. The second one is weird! For every parameter of a function, you have to supply the type of that parameter. Usually this is quite straight-forward: Int, String, MyCustomClass etc. But what is the &lt;code&gt;type&lt;/code&gt; of a function? Option-clicking on the word &lt;code&gt;cube&lt;/code&gt; in my function definition, I see this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/FunctionType.png&#34; alt=&#34;Function type&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And ignoring the parameter labels, this basically provides the function type: Int inside parentheses for the input, then the arrow, then Int again for the return type. So the type definition for the &lt;code&gt;cube&lt;/code&gt; function is &lt;code&gt;(Int) -&amp;gt; Int&lt;/code&gt;. And when I define the type for the calculation parameter in the &lt;code&gt;doCalculation&lt;/code&gt; function, this is exactly what I put. The last part of the function definition is specifiying the overall return type as an Int.&lt;/p&gt;

&lt;p&gt;Using the &lt;code&gt;cube&lt;/code&gt; and &lt;code&gt;square&lt;/code&gt; functions inside &lt;code&gt;doCalculation&lt;/code&gt; works like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;doCalculation(7, calculation: square)
doCalculation(4, calculation: cube)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But what if I didn&amp;rsquo;t want to define all the functions I might call in advance? Then I can send the function body to the &lt;code&gt;doCalculation&lt;/code&gt; function instead of using a pre-built function. This way of using a function inside another function is referred to as a closure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;doCalculation(6, calculation: { number in
    return number * 12
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;doCalculation&lt;/code&gt; function in unchanged, but instead of passing it a reference to a function, I am directly passing it the instructions it should use to get the result. As with any function, the instructions are contained within a set of curly braces. The input to this function is listed after the opening curly brace followed by the keyword &lt;code&gt;in&lt;/code&gt;. Then the function body does whatever it needs to and returns the result.&lt;/p&gt;

&lt;p&gt;You may have heard the term &lt;code&gt;trailing closure&lt;/code&gt;. This refers to a function where the last parameter is a function. If that function is called using a closure, there is a short-hand way of writing this, omitting the closure&amp;rsquo;s parameter name and moving the closing parenthesis to before the opening curly brace.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;doCalculation(16) { number in
    return number % 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; functions I showed above, this is the way their logic was supplied but here is how the filter example would look without using a closure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func checkName(_ name: String) -&amp;gt; Bool {
    return name.count &amp;gt; 3 &amp;amp;&amp;amp; !name.contains(&amp;quot; &amp;quot;)
}

func checkPlayerNamesUsingFunction(names: [String]) -&amp;gt; [String] {
    let validNames = names.filter(checkName)
    return validNames
}

let allNames = [ &amp;quot;Woody&amp;quot;, &amp;quot;Rex&amp;quot;, &amp;quot;Slinky&amp;quot;, &amp;quot;Buzz Lightyear&amp;quot;, &amp;quot;Hamm&amp;quot; ]
let checkedNames = checkPlayerNamesUsingFunction(names: allNames)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which methods you use are up to you - they all work. If you have a function that will be called in many different places, maybe it makes more sense to define it once and pass around a reference to that function. If not, a closure has the advantage that it keeps everything together. There is more to closures, particularly to do with variable scope, but I think this post has gone on long enough already&amp;hellip;. maybe next time.&lt;/p&gt;</description>
</item>
    
    <item>
<title>JSON Parsing in Swift 4</title>
<link>https://troz.net/post/2017/json-parsing-in-swift-4/</link>
<pubDate>Sun, 18 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://troz.net/post/2017/json-parsing-in-swift-4/</guid>
<description>&lt;p&gt;&lt;strong&gt;Updated:&lt;/strong&gt; 3rd September 2017.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Checked syntax using Xcode 9.0 beta 6.&lt;/li&gt;
&lt;li&gt;Added section on &lt;a href=&#34;#nulls&#34;&gt;allowing for nulls&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Since &lt;strong&gt;JSON&lt;/strong&gt; has become the de facto standard for data transfers around the
internet, there has always been a lot of interest in Swift libraries to parse
JSON into Swift classes or structs. Searching for &amp;ldquo;swift json library&amp;rdquo; on
&lt;a href=&#34;https://github.com/search?q=swift+json+library&#34;&gt;GitHub&lt;/a&gt; discovers &lt;s&gt;77&lt;/s&gt; 86 repositories. So why are there so many? And
what has Swift 4 done to &lt;em&gt;sherlock&lt;/em&gt; them all?&lt;/p&gt;

&lt;p&gt;The problem has always been converting loosely typed JSON to strictly typed
Swift which involves a lot of type casting, checking, optionals etc. Swift has
always provided access to the Objective-C methods for converting JSON to and
from NSData, NSDictionary and NSArray. (These are now called Data, Dictionary
and Array, but those labels are so universal, that I sometimes feel a more
specific nomenclature would be useful. Have you tried doing a search for
&amp;lsquo;Data&amp;rsquo;?)&lt;/p&gt;

&lt;p&gt;For sample data, I am using &lt;a href=&#34;https://jsonplaceholder.typicode.com/users&#34;&gt;https://jsonplaceholder.typicode.com/users&lt;/a&gt; which
returns 10 user objects in this format:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;id&amp;quot;: 1,
  &amp;quot;name&amp;quot;: &amp;quot;Leanne Graham&amp;quot;,
  &amp;quot;username&amp;quot;: &amp;quot;Bret&amp;quot;,
  &amp;quot;email&amp;quot;: &amp;quot;Sincere@april.biz&amp;quot;,
  &amp;quot;address&amp;quot;: {
    &amp;quot;street&amp;quot;: &amp;quot;Kulas Light&amp;quot;,
    &amp;quot;suite&amp;quot;: &amp;quot;Apt. 556&amp;quot;,
    &amp;quot;city&amp;quot;: &amp;quot;Gwenborough&amp;quot;,
    &amp;quot;zipcode&amp;quot;: &amp;quot;92998-3874&amp;quot;,
    &amp;quot;geo&amp;quot;: {
      &amp;quot;lat&amp;quot;: &amp;quot;-37.3159&amp;quot;,
      &amp;quot;lng&amp;quot;: &amp;quot;81.1496&amp;quot;
    }
  },
  &amp;quot;phone&amp;quot;: &amp;quot;1-770-736-8031 x56442&amp;quot;,
  &amp;quot;website&amp;quot;: &amp;quot;hildegard.org&amp;quot;,
  &amp;quot;company&amp;quot;: {
    &amp;quot;name&amp;quot;: &amp;quot;Romaguera-Crona&amp;quot;,
    &amp;quot;catchPhrase&amp;quot;: &amp;quot;Multi-layered client-server neural-net&amp;quot;,
    &amp;quot;bs&amp;quot;: &amp;quot;harness real-time e-markets&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The goal will be to convert this to an instance of this matching Swift struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct User {
    let id: Int
    let name: String
    let username: String
    let email: String
    let phone: String
    let website: String
    let address: Address
    let company: Company

    struct Address {
        let street: String
        let suite: String
        let city: String
        let zipcode: String
        let geo: Coordinates

        struct Coordinates {
            let lat: Double
            let lng: Double
        }
    }

    struct Company {
        let name: String
        let catchPhrase: String
        let bs: String
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing to note is that the Swift struct (and its embedded structs) use
multiple different types: Int, String, Double, Address, Coordinates, Company.
The JSON data only has strings and numbers and even then, some of the numbers
are really strings - look at the lat &amp;amp; lng entries. So converting from JSON to a
struct and back again has always been problematic, but let&amp;rsquo;s give it a go using
built-in Swift 3 processing with no external libraries.&lt;/p&gt;

&lt;h2 id=&#34;decoding-in-swift-3&#34;&gt;Decoding in Swift 3&lt;/h2&gt;

&lt;p&gt;You can insert this into a playground or &lt;a href=&#34;https://github.com/trozware/json&#34;&gt;download my playground&lt;/a&gt; and check
out the Swift 3 JSON page:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Foundation

let sampleDataAddress = &amp;quot;https://jsonplaceholder.typicode.com/users&amp;quot;
let url = URL(string: sampleDataAddress)!
let jsonData = try! Data(contentsOf: url)

struct User {
    let id: Int
    let name: String
    let username: String
    let email: String
    let phone: String
    let website: String
    let address: Address
    let company: Company

    init?(dict: [String: Any]) {
        guard
            let id = dict[&amp;quot;id&amp;quot;] as? Int,
            let name = dict[&amp;quot;name&amp;quot;] as? String,
            let username = dict[&amp;quot;username&amp;quot;] as? String,
            let email = dict[&amp;quot;email&amp;quot;] as? String,
            let phone = dict[&amp;quot;phone&amp;quot;] as? String,
            let website = dict[&amp;quot;website&amp;quot;] as? String,
            let addressDict = dict[&amp;quot;address&amp;quot;] as? [String: Any],
            let address = Address(dict: addressDict),
            let companyDict = dict[&amp;quot;company&amp;quot;] as? [String: Any],
            let company = Company(dict: companyDict)
            else {
                return nil
        }

        self.id = id
        self.name = name
        self.username = username
        self.email = email
        self.phone = phone
        self.website = website
        self.address = address
        self.company = company
    }

    struct Address {
        let street: String
        let suite: String
        let city: String
        let zipcode: String
        let geo: Coordinates

        init?(dict: [String: Any]) {
            guard
                let street = dict[&amp;quot;street&amp;quot;] as? String,
                let suite = dict[&amp;quot;suite&amp;quot;] as? String,
                let city = dict[&amp;quot;city&amp;quot;] as? String,
                let zipcode = dict[&amp;quot;zipcode&amp;quot;] as? String,
                let geoDict = dict[&amp;quot;geo&amp;quot;] as? [String: Any],
                let geo = Coordinates(dict: geoDict) else {
                    return nil
            }

            self.street = street
            self.suite = suite
            self.city = city
            self.zipcode = zipcode
            self.geo = geo
        }

        struct Coordinates {
            let lat: Double
            let lng: Double

            init?(dict: [String: Any]) {
                guard
                    let latString = dict[&amp;quot;lat&amp;quot;] as? String,
                    let lat = Double(latString),
                    let lngString = dict[&amp;quot;lng&amp;quot;] as? String,
                    let lng = Double(lngString) else {
                        return nil
                }
                self.lat = lat
                self.lng = lng
            }
        }
    }

    struct Company {
        let name: String
        let catchPhrase: String
        let bs: String

        init?(dict: [String: Any]) {
            guard
                let name = dict[&amp;quot;name&amp;quot;] as? String,
                let catchPhrase = dict[&amp;quot;catchPhrase&amp;quot;] as? String,
                let bs = dict[&amp;quot;bs&amp;quot;] as? String else {
                    return nil
            }

            self.name = name
            self.catchPhrase = catchPhrase
            self.bs = bs
        }
    }
}

if let json = try? JSONSerialization.jsonObject(with: jsonData, options: []) {
    if let jsonArray = json as? [[String: Any]] {
        let users = jsonArray.flatMap {
            User(dict: $0)
        }
        users.count
        dump(users.first)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don&amp;rsquo;t actually expect you to go through all this code in detail, but I
included it here to make it obvious how verbose this method is.&lt;/p&gt;

&lt;p&gt;The first 3 lines get the data, and I have force-unwrapped the URL and the Data
which I would not do in a production app but which is OK while testing in a
playground. Then there is a declaration of the Users struct with all its sub
structs. Each one has a failable init that tries to parse the JSON dictionary
and returns nil if the data doesn&amp;rsquo;t match, by way of a lengthy set of guard
statements. The basic layout of each struct is the same but it is very verbose.
And as an extra step, the lat and lng properties need to be converted from
Strings to Doubles.&lt;/p&gt;

&lt;p&gt;I have to confess that it took quite come time to get this right &amp;hellip; lots of
guard statements to check that the data can be converted to the required types
which meant that any typos produced an empty array. The sub-structs have to be
extracted from the JSON as Dictionaries and then initialised by themselves.&lt;/p&gt;

&lt;h2 id=&#34;decoding-in-swift-4&#34;&gt;Decoding in Swift 4&lt;/h2&gt;

&lt;p&gt;So this works, and I get an array of Users objects. But it isn&amp;rsquo;t pretty and it
takes a lot of code to do the processing. So now I am going to move on to doing
this in Swift 4. I am using Xcode 9.0 beta 6 (9M214v) so if you have a later
version, you may need to adapt to any changes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct User: Codable {
    let id: Int
    let name: String
    let username: String
    let email: String
    let phone: String
    let website: String
    let address: Address
    let company: Company

    struct Address: Codable {
        let street: String
        let suite: String
        let city: String
        let zipcode: String
        let geo: Coordinates

        struct Coordinates: Codable {
            let lat: String
            let lng: String
        }
    }

    struct Company: Codable {
        let name: String
        let catchPhrase: String
        let bs: String
    }
}

let jsonDecoder = JSONDecoder()
let users = try? jsonDecoder.decode(Array&amp;lt;User&amp;gt;.self,
                                    from: jsonData)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ignoring the complexities of converting latitude and longitude to Doubles, I get
vastly simpler code. I declare all the structs as conforming to the &lt;code&gt;Codable&lt;/code&gt;
protocol and then I can remove all the init methods and just let &lt;code&gt;JSONDecoder&lt;/code&gt;
do its magic. I just have to tell it what data type to expect - in this case an
Array of Users. I don&amp;rsquo;t have to worry about the initial conversion of the JSON
data to a Dictionary or looping through the elements using flatMap.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In the playground, I used a do&amp;hellip;catch structure to check the result of the
decode function, but I have used try? here to keep the code short.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;changing-data-types&#34;&gt;Changing data types&lt;/h2&gt;

&lt;p&gt;The lat &amp;amp; lng coordinates are stored in the JSON as Strings, but need to be
converted to Doubles for the Swift struct.&lt;/p&gt;

&lt;p&gt;This requires a custom init method for the Coordinates struct to do the
conversion from String to Double.&lt;/p&gt;

&lt;p&gt;So here is the complete code for Swift 4 - again, if you don&amp;rsquo;t want to create
your own playground, you can &lt;a href=&#34;https://github.com/trozware/json&#34;&gt;use mine&lt;/a&gt;, this time looking at the Swift 4
JSON page:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Foundation

let sampleDataAddress = &amp;quot;https://jsonplaceholder.typicode.com/users&amp;quot;
let url = URL(string: sampleDataAddress)!
let jsonData = try! Data(contentsOf: url)

struct User: Codable {
    let id: Int
    let name: String
    let username: String
    let email: String
    let phone: String
    let website: String
    let address: Address
    let company: Company

    struct Address: Codable {
        let street: String
        let suite: String
        let city: String
        let zipcode: String
        let geo: Coordinates

        struct Coordinates: Codable {
            let lat: Double
            let lng: Double

            init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                let latString = try values.decode(String.self, forKey: .lat)
                let lngString = try values.decode(String.self, forKey: .lng)
                lat = Double(latString) ?? 0
                lng = Double(lngString) ?? 0
            }
        }
    }

    struct Company: Codable {
        let name: String
        let catchPhrase: String
        let bs: String
    }
}

let jsonDecoder = JSONDecoder()
let users = try? jsonDecoder.decode(Array&amp;lt;User&amp;gt;.self, from: jsonData)

users?.count
dump(users?.first)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For comparative purposes, I counted the lines of code in each, removing the
common boiler plate of the top of each and the two lines for displaying the
results in the playground. I also removed the blank lines which I always use a
lot in my code for readability but which are not relevant when comparing code
efficiency:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Version&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Lines&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Lines if lat &amp;amp; lng are Strings&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Swift 3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;95&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;93&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Swift 4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;35&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;28&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;encoding&#34;&gt;Encoding&lt;/h2&gt;

&lt;p&gt;Encoding back to JSON is very similar. In the Swift 3 version, I would have
written a method for each struct that created a Dictionary and then used
JSONSerialization to convert the Dictionary back to JSON. This is very verbose
and tedious to write so I am not going to bother to demonstrate it here.&lt;/p&gt;

&lt;p&gt;But in Swift 4, this is even easier than decoding. Add this code to the end of
your Swift 4 JSON playground or playground page:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if let users = users {
    let jsonEncoder = JSONEncoder()
    jsonEncoder.outputFormatting = .prettyPrinted

    if let backToJson = try? jsonEncoder.encode(users) {
        if let jsonString = String(data: backToJson, encoding: .utf8) {
            print(jsonString)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;JSONEncoder&lt;/code&gt; returns Data and I have converted that to a String for
checking. I set JSONEncoder&amp;rsquo;s outputFormatting property to .prettyPrinted get a
more readable String.&lt;/p&gt;

&lt;p&gt;Notice how the encoded data is not quite the same as I received because the lat
&amp;amp; lng properties are now Doubles. In a production app, if I needed to be able to
convert back to JSON, I probably would have left them as Strings so as to enable
data transfer in both directions. I would add computed properties to the struct
to convert these Strings to Doubles as I needed them.&lt;/p&gt;

&lt;h2 id=&#34;advanced-decoding&#34;&gt;Advanced Decoding&lt;/h2&gt;

&lt;p&gt;Now that we have the basics, I want to look at three more features: changing
property names, date handling and allowing for nulls.&lt;/p&gt;

&lt;h2 id=&#34;changing-property-names&#34;&gt;Changing Property Names&lt;/h2&gt;

&lt;p&gt;In these examples I used exactly the same names for the properties as were used
in the JSON. In the Swift 3 version, it would have been easy to change the
property names, since the data for each property was being extracted manually.
In Swift 4, if you want the decoder to change names, you have to tell it what
you want.&lt;/p&gt;

&lt;p&gt;Make a new playground or playground page and replace the contents with this - or
go to the Swift 4 Extras page on &lt;a href=&#34;https://github.com/trozware/json&#34;&gt;my playground&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Foundation

let jsonString = &amp;quot;&amp;quot;&amp;quot;
{
&amp;quot;name1&amp;quot;: &amp;quot;Jane&amp;quot;,
&amp;quot;name2&amp;quot;: &amp;quot;Smith&amp;quot;
}
&amp;quot;&amp;quot;&amp;quot;
let jsonData = jsonString.data(using: .utf8)!

struct Person: Codable {
    let firstName: String
    let lastName: String
}

let jsonDecoder = JSONDecoder()
let person = try? jsonDecoder.decode(Person.self, from: jsonData)
dump(person)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This uses the new multi-line literals in Swift 4 to assemble the JSON string
which is amazingly useful as it allows quotes to be embedded in the string
without having to escape them. As you can see, the JSON property names are not
very helpful, so I want to change them in my Person struct. At the moment,
&lt;code&gt;person&lt;/code&gt; is nil because I have not given the decoder any clues to help it
translate the names. To do that, I have to add a CodingKeys enum to the Person
struct and it tells the decoder what names in the JSON match up to what
properties in the struct.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Person: Codable {
    let firstName: String
    let lastName: String

    enum CodingKeys: String, CodingKey {
        case firstName = &amp;quot;name1&amp;quot;
        case lastName = &amp;quot;name2&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s all I have to do. Now the JSON is correctly converted to a Person. As
an exercise, use JSONEncoder to get back to JSON from the Person. You will see
that the JSON correctly names the elements using &amp;ldquo;name1&amp;rdquo; and &amp;ldquo;name2&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;date-handling&#34;&gt;Date Handling&lt;/h2&gt;

&lt;p&gt;Next let&amp;rsquo;s look at dates - add this code to the playground:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let jsonString2 = &amp;quot;&amp;quot;&amp;quot;
{
&amp;quot;name&amp;quot;: &amp;quot;My New Project&amp;quot;,
&amp;quot;created&amp;quot;: &amp;quot;2017-06-18T06:28:25Z&amp;quot;
}
&amp;quot;&amp;quot;&amp;quot;
let jsonData2 = jsonString2.data(using: .utf8)!

struct Project: Codable {
    let name: String
    let created: Date
}

let jsonDecoder2 = JSONDecoder()
let project = try? jsonDecoder2.decode(Project.self, from: jsonData2)

dump(project)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When this runs, &lt;code&gt;project&lt;/code&gt; is nil because the decoder has no idea how to get from
the String &amp;ldquo;2017-06-18T06:28:25Z&amp;rdquo; to a Date object. Add this line after creating
&lt;code&gt;jsonDecoder2&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;jsonDecoder2.dateDecodingStrategy = .iso8601
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the date can be converted and an instance of the Project struct will be
created.&lt;/p&gt;

&lt;p&gt;And to get back to the JSON, converting the Date back to ISO8601 format:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let jsonEncoder = JSONEncoder()
jsonEncoder.dateEncodingStrategy = .iso8601

if let backToJson = try? jsonEncoder.encode(project) {
    if let jsonString = String(data: backToJson, encoding: .utf8) {
        print(jsonString)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name =&#34;nulls&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;allowing-for-nulls&#34;&gt;Allowing For Nulls&lt;/h2&gt;

&lt;p&gt;JSON data will often include &lt;strong&gt;null&lt;/strong&gt; where there is no value for a particular
property name. When using JSONDecoder or JSONEncoder, this can be allowed for by
using Optionals. If you are not clear about Optionals, have a look at my
previous article: &lt;a href=&#34;https://troz.net/post/2016-02-12-learning-swift-optionals/&#34;&gt;Learning Swift - Optionals&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The crucial step is to declare the properties of the Swift object as optionals
if you think they could get a null value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Role: Codable {
    let firstName: String
    let lastName: String
    let nickName: String?
}

let jsonStringWithNulls = &amp;quot;&amp;quot;&amp;quot;
[
    {
        &amp;quot;firstName&amp;quot;: &amp;quot;Sally&amp;quot;,
        &amp;quot;lastName&amp;quot;: &amp;quot;Sparrow&amp;quot;,
        &amp;quot;nickName&amp;quot;: null
    },
    {
        &amp;quot;firstName&amp;quot;: &amp;quot;Doctor&amp;quot;,
        &amp;quot;lastName&amp;quot;: &amp;quot;Who&amp;quot;,
        &amp;quot;nickName&amp;quot;: &amp;quot;The Doctor&amp;quot;
    }
]
&amp;quot;&amp;quot;&amp;quot;
let jsonDataWithNulls = jsonStringWithNulls.data(using: .utf8)!

let jsonDecoder3 = JSONDecoder()
let roles = try? jsonDecoder3.decode(Array&amp;lt;Role&amp;gt;.self, from: jsonDataWithNulls)
dump(roles)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example (which you can find in the Swift 4 Extras page on &lt;a href=&#34;https://github.com/trozware/json&#34;&gt;my
playground&lt;/a&gt;), I have declared a struct called Role with 3 String properties.
The 3rd String - nickName - is an Optional so it may be a String or it may be
nil.&lt;/p&gt;

&lt;p&gt;The JSON contains 2 elements - one has a nickName value and the other has it as
null. Because the matching property in the Swift struct is an optional, this
works as expected and the nickName property for Sally Sparrow is decoded as nil.
If you remove the question mark to make nickName non-optional, the decoding will
fail.&lt;/p&gt;

&lt;p&gt;Going back to JSON from a Swift object with optionals works much the same except
that it does not specifically mark items as null, it just leaves them out.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let jsonEncoder2 = JSONEncoder()
jsonEncoder2.outputFormatting = .prettyPrinted

if let backToJsonWithNulls = try? jsonEncoder2.encode(roles) {
    if let jsonString = String(data: backToJsonWithNulls, encoding: .utf8) {
        print(jsonString)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;property-lists&#34;&gt;Property Lists&lt;/h2&gt;

&lt;p&gt;As well as JSONDecoder and JSONEncoder, Swift 4 has introduced
PropertyListDecoder and PropertyListEncoder, so let&amp;rsquo;s take a quick look at that.&lt;/p&gt;

&lt;p&gt;Add this to the bottom of the last playground as it uses the Project struct and
data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let plistEncoder = PropertyListEncoder()
plistEncoder.outputFormat = .xml
if let plist = try? plistEncoder.encode(project) {
    if let plistString = String(data: plist, encoding: .utf8) {
        print(plistString)
    }

    let plistDecoder = PropertyListDecoder()
    let project2 = try? plistDecoder.decode(Project.self, from: plist)

    dump(project2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don&amp;rsquo;t see this is being quite as useful as the JSON Encoding &amp;amp; Decoding, but I
mention it here for completeness.&lt;/p&gt;

&lt;h2 id=&#34;codable&#34;&gt;Codable&lt;/h2&gt;

&lt;p&gt;In all the Swift 4 examples above, I set the structs to conform to &lt;code&gt;Codable&lt;/code&gt;.
Reading Apple&amp;rsquo;s docs, I see that &lt;code&gt;Codable&lt;/code&gt; is actually a typealias referring to
2 separate protocols:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;typealias Codable = Decodable &amp;amp; Encodable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you only need to convert data one way, it will be more efficient to set your
struct or class as confirming to only one of these protocols. For example, if
you download JSON data from an API but never need to send it back, just conform
to Decodable to transform the JSON data into your data structure.&lt;/p&gt;

&lt;p&gt;Much more information can be found in the &lt;a href=&#34;https://developer.apple.com/documentation/swift/encoding_decoding_and_serialization&#34;&gt;Apple documentation&lt;/a&gt;.&lt;/p&gt;</description>
</item>
    
    <item>
<title>Learning Swift - Sets</title>
<link>https://troz.net/post/2016/learning-swift-sets/</link>
<pubDate>Sat, 28 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://troz.net/post/2016/learning-swift-sets/</guid>
<description>

&lt;p&gt;Sets are the forgotten collection type in many languages, including Swift. I
think most developers use Arrays without really considering the advantages of
using a Set but they have some amazingly useful features that should make them a
part of any progammer&amp;rsquo;s toolkit.&lt;/p&gt;

&lt;p&gt;If you want to follow along with a playground, you can download it &lt;a href=&#34;https://github.com/trozware/sets&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;what-is-a-set&#34;&gt;What is a Set?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;A Set is an un-ordered collection of unique items.&lt;/strong&gt; That&amp;rsquo;s it - nothing more
than that. So it is very similar to an Array, but it is not indexed like an
Array and it cannot contain more than one of each entry.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-set&#34;&gt;Creating a Set&lt;/h2&gt;

&lt;p&gt;Creating a Set is as easy as creating an Array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var myArray = [&amp;quot;dog&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;hamster&amp;quot;, &amp;quot;dog&amp;quot;]
var mySet: Set = [&amp;quot;dog&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;hamster&amp;quot;, &amp;quot;dog&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are running these commands in a playground, notice that the differences
between the 2 results:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;[&amp;quot;dog&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;hamster&amp;quot;, &amp;quot;dog&amp;quot;]    // myArray
{&amp;quot;hamster&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;dog&amp;quot;}           // mySet
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;The Array is shown wrapped in square brackets, the Set is shown wrapped in
curly braces. This is just a visual clue and doesn&amp;rsquo;t really mean anything.
You cannot initialize a set using curly braces.&lt;/li&gt;
&lt;li&gt;All the supplied elements of the Array are listed, but the Set has removed
the duplicate &amp;ldquo;dog&amp;rdquo; element. This did not cause an error or warning, it just
happened quietly.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When initializing a Set, you must add &lt;code&gt;: Set&lt;/code&gt; to distinguish it from an array
initialization. In the example above, I did not specify the data type of the
elements in the Set as the Swift compiler was able to infer this from the
contents. But if initializing an empty array, the data type must be specified.
To check how to do this, I option-clicked on &lt;code&gt;mySet&lt;/code&gt; to see what the Swift
compiler thought it was.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/set_types.png&#34; alt=&#34;Sets&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So mySet is actually &lt;code&gt;Set&amp;lt;String&amp;gt;&lt;/code&gt;. This means that to create an empty Set, you
need to use something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var emptySetOfStrings: Set&amp;lt;String&amp;gt; = [] var
emptySetOfInts: Set&amp;lt;Int&amp;gt; = []
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-and-removing-elements&#34;&gt;Adding and removing elements&lt;/h2&gt;

&lt;p&gt;If you have been using an Array to store unique values, then you have probably
written code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if !myArray.contains(&amp;quot;cat&amp;quot;) {
  myArray.append(&amp;quot;cat&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Sets, you don&amp;rsquo;t have to care. Just use &lt;code&gt;insert()&lt;/code&gt; and let the Set work out
whether to add the item or not.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;mySet.insert(&amp;quot;goldfish&amp;quot;)
// goldfish added: {&amp;quot;hamster&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;goldfish&amp;quot;}
mySet.insert(&amp;quot;dog&amp;quot;)
// dog already there: {&amp;quot;hamster&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;goldfish&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Removing elements is also easier than in Arrays. For an Array, you first have to
find the index of the element and remove it by index:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// myArray.remove(&amp;quot;hamster&amp;quot;) // will not compile
if let index = myArray.index(of: &amp;quot;hamster&amp;quot;) {
  myArray.remove(at: index)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But in a Set, you can remove any element easily and trying to remove an element
that doesn&amp;rsquo;t exist will fail without an error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;mySet.remove(&amp;quot;hamster&amp;quot;)   // returns &amp;quot;hamster&amp;quot;
mySet.remove(&amp;quot;canary&amp;quot;)    // returns nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;converting-between-sets-and-arrays&#34;&gt;Converting between Sets and Arrays&lt;/h2&gt;

&lt;p&gt;Sometimes you need to be able to switch between the two. My most recent example
was when I wanted to store data from a Set in a plist. Sets are not property
list types but Arrays are, so I converted the Set to an Array before storing it
in the plist. When reading the data in from the plist, I converted it back to a
Set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let myArrayAsSet = Set(myArray)
let mySetAsArray = Array(mySet)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One useful side-effect of these easy conversions is the ability to &amp;lsquo;unique&amp;rsquo; an
Array in a single line. This may be inefficient for large arrays, but works very
well for small ones. Just be careful if the order of the elements is important
as you cannot guarantee the order of elements in a Set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let myArrayUniqued = Array(Set(myArray))
// [&amp;quot;cat&amp;quot;, &amp;quot;dog&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;iterating-over-elements-in-a-set&#34;&gt;Iterating over elements in a Set&lt;/h2&gt;

&lt;p&gt;As with an Array, you can use a &lt;code&gt;for element in set&lt;/code&gt; structure, or you can use
&lt;code&gt;enumerated()&lt;/code&gt;. But you cannot subscript a Set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;for animal in mySet {
  print(animal)
}

for (index, animal) in mySet.enumerated() {
  print(&amp;quot;\(index) = \(animal)&amp;quot;)
}

// will not compile
// for index in 0 ..&amp;lt; mySet.count {
//   print(&amp;quot;\(index) = \(mySet[index])&amp;quot;)
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;where-sets-get-really-interesting&#34;&gt;Where Sets get really interesting&lt;/h2&gt;

&lt;p&gt;Remember in school when you learnt about Venn diagrams with pretty interlocking
circles? Sets can do the same things, although you will have to do your own
pretty drawings :-)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let set1: Set = [&amp;quot;dog&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;pig&amp;quot;]
let set2: Set = [&amp;quot;cow&amp;quot;, &amp;quot;horse&amp;quot;, &amp;quot;pig&amp;quot;]

let intersect = set1.intersection(set2)
// {&amp;quot;pig&amp;quot;}

let subtract = set1.subtracting(set2)
// {&amp;quot;cat&amp;quot;, &amp;quot;dog&amp;quot;}

let union = set1.union(set2)
// {&amp;quot;pig&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;cow&amp;quot; &amp;quot;horse&amp;quot;}

let xor = set1.symmetricDifference(set2)
// {&amp;quot;cat&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;cow&amp;quot;, &amp;quot;horse&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code example above, we have two Sets of animals, with one animal in
common.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;intersection()&lt;/code&gt; lists the elements in common.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subtracting()&lt;/code&gt; lists the elements in one Set after removing all elements that
are in the other.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;union()&lt;/code&gt; joins all the elements without duplicates.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;symmetricDifference()&lt;/code&gt; lists the elements that are in one or other of the
Sets but not in both. (Swift 3 renamed this function from &lt;code&gt;exclusiveOr()&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is my best attempt at a pretty drawing to show how these go together:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/sets_1.png&#34; alt=&#34;Sets&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The next fun trick is working out sub-sets, super-sets and disjoint sets.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let set1: Set = [&amp;quot;dog&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;pig&amp;quot;]
let set2: Set = [&amp;quot;cow&amp;quot;, &amp;quot;horse&amp;quot;, &amp;quot;pig&amp;quot;]

let smallSet: Set = [&amp;quot;pig&amp;quot;, &amp;quot;cow&amp;quot;]

smallSet.isSubset(of: set1)   // false
smallSet.isSubset(of: set2)   // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;smallSet&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; a subset of &lt;code&gt;set1&lt;/code&gt; because it contains an element that is
not in &lt;code&gt;set1&lt;/code&gt;. &lt;code&gt;smallSet&lt;/code&gt; &lt;strong&gt;is&lt;/strong&gt; a subset of &lt;code&gt;set2&lt;/code&gt; because every element in
&lt;code&gt;smallSet&lt;/code&gt; is also in &lt;code&gt;set2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/sets_2.png&#34; alt=&#34;Sets&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you want to get technical, a Set should not be considered a subset of an
identical Set. The default &lt;code&gt;isSubset(of:)&lt;/code&gt; allows this, but you can use
&lt;code&gt;isStrictSubset(of:)&lt;/code&gt; if you prefer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;set1.isSubset(of: set1)         // true
set1.isStrictSubset(of: set1)   // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Superset works just the same but in reverse so the diagram above explains it
too:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let set1: Set = [&amp;quot;dog&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;pig&amp;quot;]
let set2: Set = [&amp;quot;cow&amp;quot;, &amp;quot;horse&amp;quot;, &amp;quot;pig&amp;quot;]

let smallSet: Set = [&amp;quot;pig&amp;quot;, &amp;quot;cow&amp;quot;]

set1.isSuperset(of: smallSet)       // false
set2.isSuperset(of: smallSet)       // true

set1.isSuperset(of: set1)           // true
set1.isStrictSuperset(of: set1)     // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;set1&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; a superset of &lt;code&gt;smallSet&lt;/code&gt; because it does not contain every
element in &lt;code&gt;smallSet&lt;/code&gt;. &lt;code&gt;set2&lt;/code&gt; &lt;strong&gt;is&lt;/strong&gt; a superset of &lt;code&gt;smallSet&lt;/code&gt; because every
element in &lt;code&gt;smallSet&lt;/code&gt; is also in &lt;code&gt;set2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;isSuperset(of:)&lt;/code&gt; and &lt;code&gt;isStrictSuperset(of:)&lt;/code&gt; functions allow or reject
identical sets.&lt;/p&gt;

&lt;p&gt;The final comparison tool that might be useful is &lt;code&gt;isDisjoint(with:)&lt;/code&gt; which
returns true only if the two Sets have no elements in common i.e. if there is no
overlap in the circles.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let set1: Set = [&amp;quot;dog&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;pig&amp;quot;]
let set2: Set = [&amp;quot;cow&amp;quot;, &amp;quot;horse&amp;quot;, &amp;quot;pig&amp;quot;]

let otherSet: Set = [&amp;quot;duck&amp;quot;, &amp;quot;chicken&amp;quot;]

set1.isDisjoint(with: set2)       // false
set1.isDisjoint(with: otherSet)   // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;pig&amp;rdquo; occurs in both &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; so they are &lt;strong&gt;not&lt;/strong&gt; disjoint. &lt;code&gt;otherSet&lt;/code&gt;
and &lt;code&gt;set1&lt;/code&gt; have no matching entries so they &lt;strong&gt;are&lt;/strong&gt; disjoint.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;when-should-you-use-a-set&#34;&gt;When should you use a Set?&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;If you want the elements to be unique.&lt;/li&gt;
&lt;li&gt;If you want easy methods of comparing the contents of different collections.&lt;/li&gt;
&lt;li&gt;If you want to be able to remove elements easily.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;when-should-you-not-use-a-set&#34;&gt;When should you not use a Set?&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;If you need the collection to be able to hold multiples of an element.&lt;/li&gt;
&lt;li&gt;If the order of the collection is important.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;For more details on Sets, check out &lt;a href=&#34;http://swiftdoc.org/v2.2/type/Set/&#34;&gt;SwiftDoc.org&lt;/a&gt;.&lt;/p&gt;
</description>
</item>
    
    <item>
<title>Structs vs Classes</title>
<link>https://troz.net/post/2016/structs-vs-classes/</link>
<pubDate>Wed, 30 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://troz.net/post/2016/structs-vs-classes/</guid>
<description>

&lt;p&gt;One of the big debates among Swift developers is when to use &lt;code&gt;structs&lt;/code&gt; and when
to use &lt;code&gt;classes&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Classes are the building blocks of object-oriented programming
but structs as provided by Swift are newly powerful. Structs have been around in
C-based languages for a long time, but Swift has made them more powerful and
given them more features so that they are almost indistinguishable from classes.
So what are the differences and which one should you use?&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;where-they-are-the-same&#34;&gt;Where they are the same?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;both can define initializers&lt;/li&gt;
&lt;li&gt;both can define properties&lt;/li&gt;
&lt;li&gt;both can define methods&lt;/li&gt;
&lt;li&gt;both can conform to protocols&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;where-they-are-different&#34;&gt;Where they are different?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;classes can inherit from other classes&lt;/li&gt;
&lt;li&gt;structs cannot inherit from other structs&lt;/li&gt;
&lt;li&gt;classes are reference types&lt;/li&gt;
&lt;li&gt;structs are value types&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;The reference type vs value type difference is where things really get
interesting. Have a look at this example of a class with a single property:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class PersonClass {
    var name: String

    init(name: String) {
        self.name = name
    }
}

var personA = PersonClass(name: &amp;quot;Woody&amp;quot;)
personA.name // Woody

var personB = personA
personB.name = &amp;quot;Buzz&amp;quot;
personB.name // Buzz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That looks like standard stuff, but what do you think &lt;code&gt;personA&lt;/code&gt;&amp;rsquo;s name is now?
If you guessed &amp;ldquo;Buzz&amp;rdquo; then you win a prize! &lt;em&gt;(No, not a real prize - pat
yourself on the back.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is because when we created the &lt;code&gt;personB&lt;/code&gt; variable and assigned &lt;code&gt;personA&lt;/code&gt; to
it, we did not assign the &lt;strong&gt;VALUE&lt;/strong&gt; of &lt;code&gt;personA&lt;/code&gt;, we assigned a &lt;strong&gt;REFERENCE&lt;/strong&gt; to
&lt;code&gt;personA&lt;/code&gt; - actually the address in memory of &lt;code&gt;personA&lt;/code&gt; rather than the data
inside.&lt;/p&gt;

&lt;p&gt;So now we have two objects and they are both looking at the same spot in memory
for their data. This means that changing the name of &lt;code&gt;personB&lt;/code&gt; changed the name
of &lt;code&gt;personA&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try the same thing with a struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct PersonStruct {
  var name: String
}

var personC = PersonStruct(name: &amp;quot;Rex&amp;quot;)
personC.name // Rex

var personD = personC
personD.name = &amp;quot;Hamm&amp;quot;
personD.name // Hamm

personC.name // Rex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time, because we are using a struct, when we assign &lt;code&gt;personC&lt;/code&gt; to the new
&lt;code&gt;personD&lt;/code&gt; variable, we are actually making a copy of &lt;code&gt;personC&lt;/code&gt; and setting the
values of &lt;code&gt;personD&lt;/code&gt; to this new copy. So now we can change &lt;code&gt;personD&lt;/code&gt; without
messing with &lt;code&gt;personC&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that I did not have a define an &lt;code&gt;init&lt;/code&gt; for the struct because it creates
one automatically. You can still add one yourself if you want to do anything
different, but you do not have to.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;At first glance, you may think that you should now use structs all the time to
avoid these unintended consequences, but it isn&amp;rsquo;t quite as simple as that.
Sometimes a class is still the best thing to use.&lt;/p&gt;

&lt;p&gt;The inheritance capabilities of classes can make your decision simple: if you
need to create a button and want to start by sub-classing UIButton or NSButton,
then your button must be a class, not a struct. This will apply to most user
interface objects.&lt;/p&gt;

&lt;p&gt;Apple really wants us to use structs and in the Swift standard libraries, a very
high percentage of the objects are structs. But structs are especially well
suited to a certain subset of objects.&lt;/p&gt;

&lt;p&gt;The best explanation that I have found of when to use a struct is the &lt;a href=&#34;http://faq.sealedabstract.com/structs_or_classes/#an-alternative-hypothesis&#34;&gt;Jeff Trick&lt;/a&gt;. Reduced down, the rule is:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you can overload == to compare two instances of your object, use a struct.
&lt;br&gt; If this doesn&amp;rsquo;t make sense, use a class.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So use structs for your things: Person, Shape, Brick, Cat. &lt;br&gt; Use classes for
everything else.&lt;/p&gt;

&lt;p&gt;I would add one caveat: don&amp;rsquo;t fight the compiler. If using a struct is giving
lots of errors and warnings, change to a class.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;A logical consequence of this is that all structs should conform to the
&lt;a href=&#34;http://swiftdoc.org/v2.2/protocol/Equatable/&#34;&gt;Equatable&lt;/a&gt; protocol.&lt;/p&gt;

&lt;p&gt;Extending &lt;code&gt;PersonStruct&lt;/code&gt; to make it conform just requires a single function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension PersonStruct: Equatable {
  static func == (lhs: PersonStruct, rhs: PersonStruct) -&amp;gt; Bool {
    return lhs.name == rhs.name
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since this struct only has one property, we can say that two instances of this
struct are equal if the names are equal.&lt;/p&gt;

&lt;p&gt;Testing this, we can see:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var personC = PersonStruct(name: &amp;quot;Rex&amp;quot;)
var personD = personC
personD.name = &amp;quot;Hamm&amp;quot;

personC == personD // false

let personE = PersonStruct(name: &amp;quot;Rex&amp;quot;)
personC == personE // true
personC != personE // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Conveniently, providing an &lt;code&gt;==&lt;/code&gt; function effectively gives us a &lt;code&gt;!=&lt;/code&gt; function
for free as you can see from the last example.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;There is one final point I would like to make about struct and that concerns
mutating functions. Look at what happens if we include a function that changes
the &lt;code&gt;name&lt;/code&gt; property in the struct:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/mutating.png&#34; alt=&#34;Mutating error&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Fix-it is very helpfully pointing out that the method needs to be marked as
&lt;code&gt;mutating&lt;/code&gt; for this to work and is showing where this should go. Accepting the
suggestion will get rid of the error and then the name can be changed using this
method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct PersonStruct: Equatable {
    var name: String

    mutating func changeName(to newName: String) {
        if !newName.isEmpty {
            name = newName
        }
    }
}

var personC = PersonStruct(name: &amp;quot;Woody&amp;quot;)
personC.name // Woody

personC.changeName(to: &amp;quot;Sid&amp;quot;)
personC.name // Sid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no problem about using &lt;code&gt;mutating&lt;/code&gt; and it will not have the unintended
consequences of using classes. Despite the scary name, a mutating function
actually returns a new copy of the struct.&lt;/p&gt;

&lt;p&gt;The problem arises if you have many nested structs and the mutating has to
spread through the list. So don&amp;rsquo;t nest your structs - at least not more than two
deep!&lt;/p&gt;
</description>
</item>
    
    <item>
<title>Learning Swift - Optionals</title>
<link>https://troz.net/post/2016/learning-swift-optionals/</link>
<pubDate>Sat, 12 Mar 2016 14:24:00 +1000</pubDate>
      
      <guid>https://troz.net/post/2016/learning-swift-optionals/</guid>
<description>&lt;p&gt;Today I plan to discuss optionals since they were a feature of Swift that I
found difficult to grasp at first.&lt;/p&gt;

&lt;h2 id=&#34;what-is-an-optional-in-swift&#34;&gt;What is an optional in Swift?&lt;/h2&gt;

&lt;p&gt;An optional is a variable of a specified type that can also be nil.&lt;/p&gt;

&lt;h2 id=&#34;why-does-this-matter&#34;&gt;Why does this matter?&lt;/h2&gt;

&lt;p&gt;In Objective-C, any object type could be nil. If you declared a variable like
this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objectivec&#34;&gt;NSString *myString;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then &lt;code&gt;myString&lt;/code&gt; was set to nil by default.&lt;/p&gt;

&lt;p&gt;But this could cause issues, especially as Objective-C does not complain if you
send a message to nil. This could lead to bugs that were very difficult to track
down.&lt;/p&gt;

&lt;p&gt;The other big use for nil is when returning from a function which has found no
appropriate data to return. The classic example is when looking for the index of
an element in an array. What should be returned if the element is not found in
the array?&lt;/p&gt;

&lt;p&gt;Some languages return -1, Objective-C uses &lt;code&gt;NSNotFound&lt;/code&gt;, but you have to know
what each language is going to do. The more logical answer is nil. However if
your function is expected to return an integer, then it cannot return nil
because nil is not an integer.&lt;/p&gt;

&lt;p&gt;This is where optionals come in: if the function is expected to return an
optional integer, it can return with an integer with the index of the matching
element, or it can return nil if the element was not found. This is much clearer
and less prone to error.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;how-does-swift-handle-optionals&#34;&gt;How does Swift handle optionals?&lt;/h2&gt;

&lt;p&gt;One of the first things that struck me about Swift was how clean the code
looked, without so many non-alphanumeric characters scattered around. Gone were
all the:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;* ; [ ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But instead, Swift code sprouted:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;! ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What were these?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The key to understanding optionals is to realise that when you declare an
optional variable of a certain type, you are actually declaring a box that can
hold a variable of that type or can hold nil.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Once you grasp that concept, it all becomes much more obvious.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var optionalInteger: Int?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The ? indicates that this is an optional variable. It does not have to be
initialised as it is already set to nil which is valid for an optional variable.
Without the ? this would require initialisation as it would not be valid for it
to be nil.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;setting-an-optional&#34;&gt;Setting an optional&lt;/h2&gt;

&lt;p&gt;Setting the value of an optional variable is just the same as any other
variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;optionalInteger = 3
optionalInteger = 42
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;getting-an-optional&#34;&gt;Getting an optional&lt;/h2&gt;

&lt;p&gt;The difference arises when you need to get the data out of the optional variable
in order to use it. This process is called un-wrapping and it means to get the
variable value out of the &amp;lsquo;box&amp;rsquo; it is stored it.&lt;/p&gt;

&lt;h3 id=&#34;the-most-obvious-way-is-to-use&#34;&gt;The most obvious way is to use !&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let newInteger = optionalInteger!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DO NOT DO THIS!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is called forced-unwrapping and assumes that the optional variable is not
nil. If the optional is nil, this will crash. In Xcode, when you connect
interface elements from your storyboard to a Swift file, Xcode will use ! like
this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@IBOutlet weak var startButton: UIButton!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have to assume Xcode knows what it is doing and the button will be available
when needed, but you should not use ! - it is un-safe. By using it, you are
vowing to the compiler that when it gets to that point, the optional value will
not be nil. There are much better and safer ways of doing that.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;use-if-let&#34;&gt;Use &amp;lsquo;if let&amp;rsquo;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func doubleNumber(_ optionalInteger: Int?) -&amp;gt; Int? {
    if let integerValue = optionalInteger {
        // integerValue is not an optional
        // and is guaranteed to contain an Int
        return integerValue * 2
    }

    // no integer found in the optional,
    // so return nil to indicate failure
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;use-guard&#34;&gt;Use guard&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func doubleNumber(_ optionalInteger: Int?) -&amp;gt; Int? {
    guard let integerValue = optionalInteger else {
        // get out quickly,
        // returning nil to indicate failure
        return nil
    }

    // integerValue is not an optional
    // and is guaranteed to contain an Int
    return integerValue * 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These two alternatives (&lt;code&gt;if let&lt;/code&gt; &amp;amp; &lt;code&gt;guard&lt;/code&gt;) do the same job but in opposite
ways. In both cases, they perform a conditional un-wrapping that may or may not
give a valid result. &lt;code&gt;if let&lt;/code&gt; checks if it is OK to proceed. &lt;code&gt;guard&lt;/code&gt; checks to
see if it is NOT OK to proceed. Which you use is really a matter of personal
preference and working out what is more logical in each case.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;guard&lt;/code&gt; statement is really good for checking data early in a process and
making a quick exit it something is wrong. The &lt;code&gt;if let&lt;/code&gt; construct encloses your
success code inside a block and can sometimes leave the failure code a long way
from the check which can make it less obvious. The other potential issue with
&lt;code&gt;if let&lt;/code&gt; is the &amp;ldquo;pyramid of doom&amp;rdquo; common in early Swift code as demonstrated in
this rather contrived example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func isValidAddressBookEntry(firstName: String?,
                             lastName: String?,
                             emailAddress: String?,
                             phoneNumber: String?) -&amp;gt; Bool {
        if let validFirstName = firstName {
            if let validLastName = lastName {
                if let validEmail = emailAddress {
                    if let validPhone = phoneNumber {
                        return true
                    }
                }
            }
        }
        return false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thankfully, Swift now allows us to chain both &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;guard&lt;/code&gt; statements.
Here is the previous example re-factored to use &lt;code&gt;if let&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func isValidAddressBookEntrySwift2(firstName: String?,
                                   lastName: String?,
                                   emailAddress: String?,
                                   phoneNumber: String?) -&amp;gt; Bool {
      if let validFirstName = firstName,
          let validLastName = lastName,
          let validEmail = emailAddress,
          let validPhone = phoneNumber {
          return true
      }
      return false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is the same function but using &lt;code&gt;guard&lt;/code&gt; which allows the inputs to be checked immediately and the function exited if the u=inputs are not valid. For a short function like this, the change is not really significant, but if the function does a lot of processing of the input data, checking first and getting out as soon as possible is more efficient.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func isValidAddressBookEntryUsingGuard(firstName: String?,
                                       lastName: String?,
                                       emailAddress: String?,
                                       phoneNumber: String?) -&amp;gt; Bool {
    guard
        let validFirstName = firstName,
        let validLastName = lastName,
        let validEmail = emailAddress,
        let validPhone = phoneNumber else {
            return false
    }

    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;use-optional-chaining&#34;&gt;Use optional chaining&lt;/h3&gt;

&lt;p&gt;The final way to deal with optionals safely is to use optional chaining:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct SocialMediaAccounts {
    var facebook: Person?
    var twitter: Person?
}

struct Person {
    var firstName: String?
    var lastName: String?
    var handle: String?
}

var socialMedia: SocialMediaAccounts?
socialMedia = SocialMediaAccounts()
var twitterAccount = Person()

socialMedia?.twitter = twitterAccount
let twitterHandle = socialMedia?.twitter?.handle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, we have defined a &lt;code&gt;SocialMediaAccounts&lt;/code&gt; struct that holds
optional &lt;code&gt;Person&lt;/code&gt; structs for the various social media outlets. The
&lt;code&gt;socialMedia&lt;/code&gt; variable is defined as an optional and then created. A
&lt;code&gt;twitterAccount&lt;/code&gt; variable of type &lt;code&gt;Person&lt;/code&gt; is also created but contains no data
at the moment.&lt;/p&gt;

&lt;p&gt;When assigning the &lt;code&gt;twitterAccount&lt;/code&gt; to the &lt;code&gt;socialMedia.twitter&lt;/code&gt; property, a ?
is inserted which checks to see that &lt;code&gt;socialMedia&lt;/code&gt; is not nil. If it is nil,
then execution of that line stops at the ? and nothing bad will happen.&lt;/p&gt;

&lt;p&gt;In the same way, when trying to read back the twitter handle, we chained
together 2 optionals with ?&amp;rsquo;s. If either &lt;code&gt;socialMedia&lt;/code&gt; or &lt;code&gt;socialMedia.twitter&lt;/code&gt;
is nil, that line will not complete. Again this is perfectly safe and the app
will not crash.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;All the examples in this article are available in a &lt;a href=&#34;https://github.com/trozware/optionals&#34;&gt;Swift playground&lt;/a&gt; which
has been updated to Swift 4 syntax.&lt;/p&gt;</description>
</item>
    
    <item>
<title>Learning Swift - For-Loops</title>
<link>https://troz.net/post/2016/learning-swift-for-loops/</link>
<pubDate>Sat, 12 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://troz.net/post/2016/learning-swift-for-loops/</guid>
<description>&lt;p&gt;Loops are a fundamental building block of any program. Doing repetitive tasks
fast and accurately is what computers are really good at and what we humans get
very bored doing. Swift offers several different ways to perform loops, but
today we are going to concentrate on for-loops.&lt;/p&gt;

&lt;p&gt;The most basic form of loop is the &lt;code&gt;for-in&lt;/code&gt; loop. There are two ways this can be
used: looping over the numbers in a range or looping over the elements in an
array or dictionary.&lt;/p&gt;

&lt;p&gt;Firstly, the range:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;for x in 0 ..&amp;lt; 5 { printWithSpace(x) }
// prints: 0 1 2 3 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;I am using a custom print function that allows me to print the results on a
single line for convenience.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This &lt;code&gt;for-in&lt;/code&gt; loop uses a half-open range and it is effectively saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;start with x at 0
print x with a space
add 1 to x
is x still less than 5?
    yes - go back to the print stage
    no - stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we wanted to go all the way to 5 instead of stopping before 5, we would use a
closed range by replacing &lt;code&gt;..&amp;lt;&lt;/code&gt; with &lt;code&gt;...&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;for x in 0 ... 5 { printWithSpace(x) }
// prints: 0 1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;These methods work fine if we want to loop through a range of numbers one at a
time but what if we want a different increment? There are several ways to vary
the step.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stride(from:to:by:)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stride(from:through:by:)&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;where&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;for x in stride(from: 0, to: 10, by: 2) {
printWithSpace(x)
}
// prints: 0 2 4 6 8
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;for x in stride(from: 0, through: 10, by: 2) {
printWithSpace(x)
}
// prints: 0 2 4 6 8 10
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The 2 variations of &lt;code&gt;stride&lt;/code&gt; are analogous to the 2 ways of expressing the range
in the the &lt;code&gt;for-in&lt;/code&gt; loop.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;stride(from:to:by:)&lt;/code&gt; starts with the number in the &lt;code&gt;from&lt;/code&gt; parameter and each
time through the loop, increments that number by the amount of the &lt;code&gt;by&lt;/code&gt;
parameter. If the incremented number is less than the &lt;code&gt;to&lt;/code&gt; parameter, the loop
continues.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;stride(from:through:by:)&lt;/code&gt; works the same way but continues until the
incremented number is greater than or equal to the &lt;code&gt;through&lt;/code&gt; parameter.&lt;/p&gt;

&lt;p&gt;Using a negative value for &lt;code&gt;by&lt;/code&gt; allows counting backwards:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;for x in stride(from: 10, through: 0, by: -2) {
  printWithSpace(x)
}
// prints: 10 8 6 4 2 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Stride can also be used for floating point loops although the result may contain
some unexpected changes in precision e.g 0.7000000000000001 instead of the
expected 0.7&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let startingNumber = 0.1
for x in stride(from: startingNumber, through: 1.0, by: 0.2) {
  printWithSpace(x)
}
// prints: 0.1 0.3 0.5 0.7000000000000001 0.9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the result does not contain the &lt;code&gt;through&lt;/code&gt; parameter as the next
iteration would have produced 1.1 which is greater than it. And also
&lt;code&gt;startingNumber&lt;/code&gt; did not have to be a variable as it is never actually changed.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;where&lt;/code&gt; makes it possible to step through a loop while conforming to some
conditional:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;for x in 0 ... 10 where x % 3 == 0 {
  printWithSpace(x)
}
// prints: 0 3 6 9
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;The other main use for &lt;code&gt;for-in&lt;/code&gt; loops is for iterating through the elements of
an array or dictionary:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let arrayOfInts = [ 1, 2, 3, 4, 5, 6 ]
for x in arrayOfInts {
  printWithSpace(x * 2)
}
// prints: 2 4 6 8 10 12
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let myDict = [ 1: &amp;quot;one&amp;quot;, 2: &amp;quot;two&amp;quot;, 3: &amp;quot;three&amp;quot; ]
for (key, value) in myDict {
  print(&amp;quot;\(key) = \(value)&amp;quot;)
}
// prints:
// 2 = two
// 3 = three
// 1 = one
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a dictionary is un-sorted, the order of the items may vary.&lt;/p&gt;

&lt;p&gt;If you want to loop through an array while also monitoring the index of each
element, you can use &lt;code&gt;enumerated()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let arrayOfNames = [ &amp;quot;Andy&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;Woody&amp;quot; ]
for (index, element) in arrayOfNames.enumerated() {
  print(&amp;quot;The name at index \(index) is \(element)&amp;quot;)
}
// prints:
// The name at index 0 is Andy
// The name at index 1 is Buzz
// The name at index 2 is Woody
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your array contains optionals, you can use &lt;code&gt;for case let&lt;/code&gt; to test each value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let arrayWithOptionals: [String?] = [ &amp;quot;Woody&amp;quot;, nil, &amp;quot;Buzz&amp;quot;, nil, &amp;quot;Rex&amp;quot; ]
for case let name? in arrayWithOptionals {
  printWithSpace(name)
}
// prints: Woody Buzz Rex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;name&lt;/code&gt; variable is un-wrapped each time through the loop so can be used
safely.&lt;/p&gt;

&lt;p&gt;Any of these loop styles can be combined with &lt;code&gt;where&lt;/code&gt; to perform checks on each
iteration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let arrayWithOptionals: [String?] = [ &amp;quot;Woody&amp;quot;, nil, &amp;quot;Buzz&amp;quot;, nil, &amp;quot;Rex&amp;quot; ]
for case let name? in arrayWithOptionals where name.count &amp;lt; 5 {
  printWithSpace(name)
}
// prints: Buzz Rex
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Some of you may be wondering what happened to the old C-style loops like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;for var x = 0; x &amp;lt; 5; x++ { print(x, terminator: &amp;quot; &amp;quot;) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This does not work in Swift 3+: the &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; operators and this style of
loop declaration have been removed from the language. For further details, check
out the relevant proposals at Swift Evolution:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md&#34;&gt;Remove C-style for-loops with conditions and incrementers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md&#34;&gt;Remove the ++ and &amp;ndash; operators&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;All the examples in this article are available in a &lt;a href=&#34;https://github.com/trozware/for-loops&#34;&gt;Swift playground&lt;/a&gt; now
updated to Swift 4 syntax.&lt;/p&gt;
</description>
</item>
    
    <item>
<title>Learning Swift - Generics</title>
<link>https://troz.net/post/2016/learning-swift-generics/</link>
<pubDate>Mon, 29 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://troz.net/post/2016/learning-swift-generics/</guid>
<description>&lt;p&gt;One of the nice things about Swift is how clean your code looks. A lot of the
weird characters that pepper the code of other languages has been eliminated: No
more semi-colons, asterisks etc.&lt;/p&gt;

&lt;p&gt;But then you are reading somebody else&amp;rsquo;s code and you find these angle brackets
all over the place and they don&amp;rsquo;t seem to make sense.&lt;/p&gt;

&lt;p&gt;What does this mean?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func mid&amp;lt;T: Comparable&amp;gt;(array: [T]) -&amp;gt; T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It looks like it is a function to find the middle element in an array, but what
is &lt;code&gt;&amp;lt;T: Comparable&amp;gt;&lt;/code&gt; or &lt;code&gt;[T]&lt;/code&gt; or even just &lt;code&gt;T&lt;/code&gt;? They are describing Generic data
types.&lt;/p&gt;

&lt;p&gt;Using the dictionary, I find the following definition for &lt;code&gt;generic&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;characteristic of or relating to a class or group of things; not specific.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And that really provides quite a good definition for Swift&amp;rsquo;s generics too. They
allow you to assign a non-specific data type to a function so that function can
be used for many different data types.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;But enough of the theory: by far the best way to understand generics is to
encounter the problem they are meant to solve and then to solve it.&lt;/p&gt;

&lt;p&gt;The other day I was processing data to feed to a charting library. I ended up
with an array of CGFloats, but there were too many of them, so I wrote a
function to give me the last x elements of an array of CGFloats:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func endOf(array: [CGFloat], numberOfElementsToInclude: Int) -&amp;gt; [CGFloat] {
  if numberOfElementsToInclude &amp;gt; array.count { return array }

  let startingElement = array.count - numberOfElementsToInclude
  let endOfArray = Array(array[startingElement ..&amp;lt; array.count])
  return endOfArray
}

let largeArray: [CGFloat] = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
let smallArray = endOf(array: largeArray, numberOfElementsToInclude: 3)
//smallArray now equals [8.0, 9.0, 10.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, so &lt;code&gt;largeArray&lt;/code&gt; isn&amp;rsquo;t actually the largest array you have ever seen, but it
works for demo purposes. In my code, I had over 20,000 entries in the large
array and only wanted the last 5,000.&lt;/p&gt;

&lt;p&gt;I was completely happy with that until I found another data source where the
data was an array of Ints. Still perfectly chartable using my charting library,
but I could not get the end of the array using my nice function. First thought
was to replicate the function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func endOf(array: [Int], numberOfElementsToInclude: Int) -&amp;gt; [Int] {
  if numberOfElementsToInclude &amp;gt; array.count { return array }

  let startingElement = array.count - numberOfElementsToInclude
  let endOfArray = Array(array[startingElement ..&amp;lt; array.count])
  return endOfArray
}

let largeArrayInt = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] // type inferred to be Int
let smallArrayInt = endOf(array: largeArrayInt, numberOfElementsToInclude: 7)
// smallArrayInt now equals [4, 5, 6, 7, 8, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A quick glance will reveal that the declaration line was the only thing that
changed. I didn&amp;rsquo;t have to give the function a new name because the compiler
worked out which of the two functions to use based on the types supplied. So all
I was doing was replacing &lt;code&gt;CGFloat&lt;/code&gt; with &lt;code&gt;Int&lt;/code&gt; in two places (the
&lt;code&gt;numberOfElementsToInclude&lt;/code&gt; parameter remains an &lt;code&gt;Int&lt;/code&gt; in both cases).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;As soon as you find yourself replicating code and only changing the types of
the data, that is a sign that you need to use generics.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For my first attempt at creating a generic function, all I did was replace the
word &lt;code&gt;CGFloat&lt;/code&gt; with &lt;code&gt;T&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; indicates some type that will be specified
when the function is called. The convention is to use single letters for generic
types: &lt;code&gt;T&lt;/code&gt; for Type, &lt;code&gt;A&lt;/code&gt; for AnyObject, &lt;code&gt;Z&lt;/code&gt; because you feel like it. The choice
is up to you.&lt;/p&gt;

&lt;p&gt;That produced this error:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/Generics_error.png&#34; alt=&#34;Generics error&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Use of undeclared type &#39;T&#39;&lt;/code&gt;. Well that seems fair enough&amp;hellip; how is the compiler
supposed to know what a &lt;code&gt;T&lt;/code&gt; is?&lt;/p&gt;

&lt;p&gt;It turns out that this is where the angle brackets come into play. You have to
warn the compiler that this function is going to get a generic type and that the
&lt;code&gt;T&lt;/code&gt; is only a placeholder, not a real type. So this version compiles and works -
notice the &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; between the function name and the opening bracket:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func endOf&amp;lt;T&amp;gt;(array: [T], numberOfElementsToInclude: Int) -&amp;gt; [T] {
  if numberOfElementsToInclude &amp;gt; array.count { return array }

  let startingElement = array.count - numberOfElementsToInclude
  let endOfArray = Array(array[startingElement ..&amp;lt; array.count])
  return endOfArray
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I have no code duplication and if I ever get another data set that uses a
different object type, my function will still work.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Now we know to use generics instead of replicating code that operates in the
same way on different data types.&lt;/p&gt;

&lt;p&gt;And we know how to construct a generic function.&lt;/p&gt;

&lt;p&gt;Using it is identical to using the two functions I had before:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let largeArray: [CGFloat] = [ 1.0, 2.0, 3.0, 4.0, 5.0,6.0, 7.0, 8.0, 9.0, 10.0 ]
let smallArray = endOf(array: largeArray, numberOfElementsToInclude: 3)

let largeArrayInt = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] // type inferred to be Int
let smallArrayInt = endOf(array: largeArrayInt, numberOfElementsToInclude: 7)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You do not have to specify what &lt;code&gt;T&lt;/code&gt; is when calling the function, that will be
inferred from the supplied data.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Moving on into more advanced use cases, we have two things to consider:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Functions where the generic parameters must conform to a protocol.&lt;/li&gt;
&lt;li&gt;Functions that take generic parameters of different types.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The example function I started with (not mine but I forget where I got it&amp;hellip; If
it is yours, thanks you very much) used:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func mid &amp;lt;T: Comparable&amp;gt; (array: [T]) -&amp;gt; T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of specifying the type as completely generic, it specified that it must
conform to the Comparable protocol. This is because the function body used a
&lt;code&gt;sort()&lt;/code&gt; function so the generic function needed to be sure that the elements in
the array could be compared. This technique can also be used to restrict the
parameter types to sub-classes of a certain class.&lt;/p&gt;

&lt;p&gt;For a function with more than one generic data type, you need to use more than
one placeholder letter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func genericWithTwoDifferentTypes&amp;lt;T, U&amp;gt;(param1: T, param2: U) -&amp;gt; Bool {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in exactly the same way, both &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; can be set to conform to a
protocol or be members of a certain super-class.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Hopefully this has taken some of the mystery out of generics, but if you have
any questions, please get in touch using the &lt;a href=&#34;https://troz.net/contact/&#34;&gt;Contact page&lt;/a&gt;, comment below or
contact me via Twitter: &lt;a href=&#34;https://twitter.com/trozware&#34;&gt;@trozware&lt;/a&gt;.&lt;/p&gt;
</description>
</item>
    
    <item>
<title>Singleton to Protocol</title>
<link>https://troz.net/post/2016/singleton-to-protocol/</link>
<pubDate>Fri, 26 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://troz.net/post/2016/singleton-to-protocol/</guid>
<description>

&lt;p&gt;I was driving through the town of &lt;a href=&#34;https://en.wikipedia.org/wiki/Singleton,_New_South_Wales&#34;&gt;Singleton&lt;/a&gt; the other day and of course, it
got me thinking about using singletons in my apps. Singletons were a commonly
used pattern in Objective-C programming and appear in many of Apple&amp;rsquo;s own APIs,
but seem to be increasingly frowned upon in the Swift world.&lt;/p&gt;

&lt;h2 id=&#34;so-what-is-a-singleton&#34;&gt;So what is a singleton?&lt;/h2&gt;

&lt;p&gt;A singleton is a class that only expects to have a single instance. Think of it
as a global instance of a class. In some cases this makes perfect sense if there
can only ever be one instance of a particular class or if there is a default
variant that suits most cases e.g.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;UIApplication.shared
UserDefaults.standard
NotificationCenter.default
FileManager.default
URLSession.shared
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are using an object with a property name of &amp;ldquo;shared&amp;rdquo;, &amp;ldquo;standard&amp;rdquo; or
&amp;ldquo;default&amp;rdquo; you can be pretty sure it is an singleton.&lt;/p&gt;

&lt;h2 id=&#34;and-what-s-the-problem-with-singletons&#34;&gt;And what&amp;rsquo;s the problem with singletons?&lt;/h2&gt;

&lt;p&gt;There are probably many different opinions here but I have two thoughts about
this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;They are effectively global variables and global variables can make your code
messy and un-predictable.&lt;/li&gt;
&lt;li&gt;If they can be accessed by multiple other objects, possibly at the same time,
then you can get conflicts. These can be handled by clever use of background
queues, but it isn&amp;rsquo;t easy.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;what-to-use-instead&#34;&gt;What to use instead?&lt;/h2&gt;

&lt;p&gt;As I drove, I mused on a singleton that I had implemented recently. It was a
logging utility that allowed any object in my app (mostly view controllers) to
save a new entry to a log file. The basic structure of the Logger class was
this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Logger {
    static let sharedLogger = Logger()

    func addToLog(event: String) {
      // use private functions to find log file URL
      // append event text with time stamp
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any object in my app could use the Logger like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Logger.sharedLogger.addToLog(event: newLogEvent)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I got to think about how I was using this, I realised that instead of a
Logger &lt;em&gt;object&lt;/em&gt; that everything could use, what I really needed was a Loggable
&lt;em&gt;behaviour&lt;/em&gt; that I could apply &amp;amp; restrict to the few classes that actually
needed to log events. For me, this was the break-through:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Create a behaviour, not an object.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As soon as I started thinking about this as a behaviour, a protocol became the
obvious solution, so this is what I created:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol Loggable {
  // not declaring functions here
  // as they should NOT be over-written
}

extension Loggable {

    func addToLog(event: String) {
      // use private functions to find log file URL
      // append event text with time stamp
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We run immediately into one of the peculiarities of Swift protocol extensions
which has been very well explained by &lt;a href=&#34;https://cjwirth.com/tech/swift-protocol-extension-weirdness&#34;&gt;Caesar Wirth&lt;/a&gt;. If I had declared
&lt;code&gt;addToLog(_:)&lt;/code&gt; in the protocol, then any class or struct conforming to this
protocol would have been free to over-write this function and provide its own
version. This is not what I wanted here - I wanted every object to use the same
version. So I left the function declaration out of the protocol definition and
only included it in the protocol extension.&lt;/p&gt;

&lt;p&gt;To use this behaviour, a class or struct just has to be declared as conforming
to the Loggable protocol:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class MyClass: Loggable {
  func doSomething() {
    addToLog(event: &amp;quot;I did something!&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For my app, I knew that I would want all my NSViewControllers to be able to add
log events, so instead of setting them all individually as conforming to the
protocol, I used this shortcut which extends all NSViewControllers to conform to
the protocol.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension NSViewController: Loggable {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I added this line to the Loggable.swift file where I declared the protocol and
its extension, but outside both of them.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Protocol-oriented programming is a new technique to me, so it really helps when
I can find a practical example of where it solves a problem.&lt;/p&gt;

&lt;p&gt;If you are new to POP, I highly recommend the &lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2015/408/&#34;&gt;Crusty talk&lt;/a&gt; from WWDC 2015.
And this article by &lt;a href=&#34;http://matthijshollemans.com/2015/07/22/mixins-and-traits-in-swift-2/&#34;&gt;Matthijs Hollemans&lt;/a&gt; was invaluable to me in
demonstrating the problems with object inheritance that are solved by protocols.&lt;/p&gt;
</description>
</item>
    
    <item>
<title>Three Rules for Writing Better Swift</title>
<link>https://troz.net/post/2016/three-rules-for-writing-better-swift/</link>
<pubDate>Wed, 24 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://troz.net/post/2016/three-rules-for-writing-better-swift/</guid>
<description>&lt;ol&gt;
&lt;li&gt;Do not use !.&lt;/li&gt;
&lt;li&gt;Use let, not var.&lt;/li&gt;
&lt;li&gt;Allow the compiler to infer types.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Read on for more details&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;1-do-not-use&#34;&gt;1. Do not use !&lt;/h2&gt;

&lt;p&gt;Swift uses optionals for values that can be nil. To use an optional value, you
need to &amp;ldquo;un-wrap&amp;rdquo; it first, which means getting the actual value out, assuming
that the value exists and the optional is not actually nil.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://troz.net/post/2016-02-12-learning-swift-optionals/&#34;&gt;Optionals&lt;/a&gt; are the subject of a complete post by themselves, but for now, I
will just say this: When you use ! you are &lt;strong&gt;promising&lt;/strong&gt; the compiler that you
will make sure there is a real value in that optional by the time it is needed.&lt;/p&gt;

&lt;p&gt;If this is not the case, your app will crash as shown in this playground:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/Playground2.png&#34; alt=&#34;Playground crash&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Instead of using ! you should use optional chaining with ? or check the value
with &lt;code&gt;guard&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; before use.&lt;/p&gt;

&lt;p&gt;One trap to beware of is with Xcode&amp;rsquo;s attempts to be helpful and suggest fixes
to problems. If you use an optional where it cannot work, Xcode will warn you
that it is incorrect, but the suggested fix will be to insert !&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/optional_fix.png&#34; alt=&#34;Optional fix&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When you see this, do not accept the suggested fix, but use it as a warning to
show that you need to fix the problem properly.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;2-use-let-not-var&#34;&gt;2. Use let, not var&lt;/h2&gt;

&lt;p&gt;Using constants in C-based languages is a pain. I could never remember the
Objective-C syntax for declaring a static constant, so used to fall back to
using &lt;code&gt;#define&lt;/code&gt; for global constants. Inside my objects, all instance properties
were variables, not constants. Inside functions, it was the same.&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t take much imagination to work out that your apps will perform better
and more securely if values that do not need to change are allocated as
constants instead of variables.&lt;/p&gt;

&lt;p&gt;With Swift, this is easy as you just declare a constant using the &lt;code&gt;let&lt;/code&gt; keyword
and declare variables using &lt;code&gt;var&lt;/code&gt;. The Swift compiler will now warn you if you
have used &lt;code&gt;var&lt;/code&gt; where &lt;code&gt;let&lt;/code&gt; would do, but I prefer to declare everything using
&lt;code&gt;let&lt;/code&gt; and only change to &lt;code&gt;var&lt;/code&gt; when this causes an error as shown in this
playground example:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/Playground3.png&#34; alt=&#34;Playground let error&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;3-allow-the-compiler-to-infer-types&#34;&gt;3. Allow the compiler to infer types&lt;/h2&gt;

&lt;p&gt;With Objective-C and many other languages, you have to tell the compiler exactly
what each variable is going to be: a string, an integer, an object of a certain
type.&lt;/p&gt;

&lt;p&gt;With Swift, the compiler is clever enough to work this out for you, which can
make your code much cleaner looking and easy to read.&lt;/p&gt;

&lt;p&gt;There are a few exceptions to this rule which are shown in the playground below:&lt;/p&gt;

&lt;p&gt;Lines 3 - 6 are allowing the Swift compiler to decide what the type is and it is
choosing valid types: Int, Double, String and UIView.&lt;/p&gt;

&lt;p&gt;Line 8 is a case where we do not want the default type, which would be Double so
we need to tell the compiler that this one really should be a CGFloat.&lt;/p&gt;

&lt;p&gt;Lines 10 &amp;amp; 11 both deal with an array of Ints. In line 10, the values are
supplied so the type of the array can be inferred. In the second case, the array
is initially empty, so the type needs to be specified in the declaration.&lt;/p&gt;

&lt;p&gt;Lines 13 and 14 are the same but with dictionaries instead of arrays.&lt;/p&gt;

&lt;p&gt;In each case, it would have been valid Swift to specify the type but why bother?
The more text you enter , the more change of mistake and it leaves your code
looking cluttered.&lt;/p&gt;

&lt;p&gt;If you ever need to check what type has been assigned to a constant or variable,
Option-click on it in Xcode and you willl get a popup telling you what it is.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/Playground4.png&#34; alt=&#34;Playground types&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;This was going to be five rules, but then I got a bit too verbose so will add
more rules in a separate post.&lt;/p&gt;</description>
</item>
    
    <item>
<title>Configuring Xcode</title>
<link>https://troz.net/post/2016/configuring-xcode/</link>
<pubDate>Wed, 17 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://troz.net/post/2016/configuring-xcode/</guid>
<description>

&lt;p&gt;While not strictly a part of my Learning Swift series, today I thought I would
discuss some of the ways to configure and use Xcode to be a more productive and
comfortable programmer.&lt;/p&gt;

&lt;h2 id=&#34;1-editor-color-themes-and-fonts&#34;&gt;1. Editor color themes and fonts:&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/XcodeFontPrefs.png&#34; alt=&#34;Editor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Step through the supplied themes and find the best one for you. Then click the
&amp;lsquo;+&amp;rsquo; button at the bottom of the list and duplicate the selected theme. Now you
can tweak it to suit you. Each text category can have its own font and size, but
you can make multiple selections in order to do a bulk change. don&amp;rsquo;t forget to
check out the Console section too - I dislike the default bold text for many of
the console reports, so always change that.&lt;/p&gt;

&lt;p&gt;An editing font should be mono-spaced i.e. every character should take up
exactly the same width on the screen. This makes your code look neater and
neater code is easier to read when you come back to it. I also much prefer a
sans-serif font, but that is a matter of preference.&lt;/p&gt;

&lt;p&gt;Menlo is the font used by Xcode as a default, but there are many other options
either in the default installation of OS X or as free downloads. I change every
now and then just to keep things interesting, but my current selection is &lt;a href=&#34;https://github.com/tonsky/FiraCode&#34;&gt;Fira
Code&lt;/a&gt;. I love the way it merges two character symbols into a single
character for faster comprehension.&lt;/p&gt;

&lt;p&gt;My other favourites are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/adobe-fonts/source-code-pro&#34;&gt;Source Code Pro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chrissimpkins/hack&#34;&gt;Hack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mozilla/Fira&#34;&gt;Fira&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.fontsquirrel.com/fonts/Inconsolata&#34;&gt;Inconsolata&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Look for a font that makes it easy to distinguish the digit &amp;lsquo;1&amp;rsquo; from a lowercase
&amp;lsquo;l&amp;rsquo; and where the digit &amp;lsquo;0&amp;rsquo; is different to the &amp;lsquo;O&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;To install and use a new font, download the files and then double-click a TTF or
OTF font file to install it in FontBook. Once the font is installed, you may
need to restart Xcode in order to make it available.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;2-add-ons&#34;&gt;2. Add-ons:&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Xcode 8 has removed the ability to run any plugins or to use
Alcatraz, so this sectrion is no longer valid. Instead Apple is offering offical
support for Xcode Source Editor Extensions, so they are the way of the future.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;3-documentation&#34;&gt;3. Documentation:&lt;/h2&gt;

&lt;p&gt;Xcode has excellent documentation, but unless you specifically download it, this
will all be accessed online. If you have a bad or non-existent connection, this
can be annoying. Go to Xcode&amp;rsquo;s Preferences -&amp;gt; Downloads and download all the
document sets you are interested in. They are quite large, but having them local
will be a big bonus.&lt;/p&gt;

&lt;p&gt;The other tool I use for documentation is &lt;a href=&#34;https://kapeli.com/dash&#34;&gt;Dash&lt;/a&gt;. It supports many languages
and is not just for use in Xcode. I found the Xcode integration plugin was not
very useful as it conflicted with other useful behaviours. So I set up a global
shortcut in System Preferences to search Dash for the selected text. This is
much faster than Xcode&amp;rsquo;s built-in documentation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/Dash.png&#34; alt=&#34;Dash&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;4-other-preferences&#34;&gt;4. Other preferences:&lt;/h2&gt;

&lt;p&gt;Go through the preference panes in Xcode&amp;rsquo;s preferences and tweak to suit your
style or your group&amp;rsquo;s preferred style.&lt;/p&gt;

&lt;p&gt;General and Text Editing are important. Text Editing has a second tab for
Indentation which is easy to miss. Indentation styles seem to cause a lot of
heated debate, so make sure you check this out.&lt;/p&gt;

&lt;p&gt;Accounts is vital if you are publishing to the App Stores and also makes it easy
to transfer all your develop information from one computer to another.&lt;/p&gt;

&lt;p&gt;Fonts &amp;amp; Colors and Downloads are discussed above.&lt;/p&gt;

&lt;p&gt;I tend to leave the others set to the defaults.&lt;/p&gt;
</description>
</item>
    
    <item>
<title>How do I start to learn Swift?</title>
<link>https://troz.net/post/2016/how-do-i-start-to-learn-swift/</link>
<pubDate>Tue, 16 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://troz.net/post/2016/how-do-i-start-to-learn-swift/</guid>
<description>&lt;p&gt;The first thing to do is to download the latest version of Apple&amp;rsquo;s &lt;a href=&#34;https://itunes.apple.com/book/swift-programming-language/id881256329&#34;&gt;Swift
Programming Language book&lt;/a&gt; from the iBooks Store.&lt;/p&gt;

&lt;p&gt;You can just read this book, especially the first section: &amp;ldquo;A Swift Tour&amp;rdquo;, but
you will get more out of it if you follow along with the playground. There is a
link to download the playground from the book which you can use directly if you
are reading using iBooks on the Mac. If you are not, here is the &lt;a href=&#34;https://developer.apple.com/go/?id=swift-tour&#34;&gt;download
link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You will also need to install &lt;a href=&#34;https://itunes.apple.com/app/xcode/id497799835&#34;&gt;Xcode&lt;/a&gt; from the Mac App Store. Xcode is
Apple&amp;rsquo;s IDE and is used for programming Mac, iPhones, iPads, Apple Watches and
Apple TVs.&lt;/p&gt;

&lt;p&gt;Swift introduced the playground to Xcode. A playground is a fantastic way to
learn and experiment. You do not need to create a project, build, run a separate
app, install on a device. Code typed into a playground is run immediately and
you can see the results instantly, line by line.&lt;/p&gt;

&lt;p&gt;Here is an example of a playground showing the code on the left and the result
of each line appearing on the right.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://troz.net/images/Playground1.png&#34; alt=&#34;Playground&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Once you have gone through the Swift Tour, Apple&amp;rsquo;s book becomes more of a
reference guide to return to whenever you get stuck. The other way I use it is
to check up on changes made when a new version of Swift is released. As the
language is still rapidly evolving, these can be quite extensive. Once I have
the latest version of the book, I go to the Revision History at the back and
click the links to read about the features that have been added or changed.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Apart from Apple&amp;rsquo;s documentation, there are a lot of great web sites, blogs and
Twitter accounts out there. There are also useful newsletters that give a weekly
summary of exciting developments.&lt;/p&gt;

&lt;p&gt;Here are some of my favourites:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.natashatherobot.com&#34;&gt;Natasha the Robot&lt;/a&gt; - my favourite Swift blogger - sign up for her
newsletter and follow her on Twitter.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/swift/blog/&#34;&gt;Apple&amp;rsquo;s Swift Blog&lt;/a&gt; - not many posts, but good for learning about new
features.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ericasadun.com&#34;&gt;Erica Sadun&lt;/a&gt; - sometimes a bit too technical for me, but often contains
some really useful snippets. Erica has the distinction of being the first
person outside Apple to have had a Swift language proposal accepted as part of
the open source development process.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://andybargh.com&#34;&gt;Andy Bargh&lt;/a&gt; - detailed articles on various aspects of Swift, plus a
weekly newsletter.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.raywenderlich.com&#34;&gt;Ray Wenderlich tutorials&lt;/a&gt; - search for Swift and find heaps of tutorials
covering many different aspects.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://swiftsandbox.io&#34;&gt;Swift Sandbox&lt;/a&gt; - weekly newsletter filled with interesting articles.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://swiftmonthly.com&#34;&gt;SwiftMonthly&lt;/a&gt; - useful newsletter with links to tutorials, videos and
projects.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://swiftdoc.org&#34;&gt;SwiftDoc.org&lt;/a&gt; - the documentation in Xcode is still heavily skewed
towards Objective-C programmers and it can be difficult to find Swift-specific
entries. This site makes it easy.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And I hope you will keep coming back to this site to see what new Swift-related
articles are available.&lt;/p&gt;
</description>
</item>
    
    <item>
<title>Why is Swift so great?</title>
<link>https://troz.net/post/2016/why-is-swift-so-great/</link>
<pubDate>Wed, 10 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://troz.net/post/2016/why-is-swift-so-great/</guid>
<description>

&lt;p&gt;Firstly, I can give you the technical answer, as published by Apple:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Swift is a new programming language for iOS, OS X, watchOS, and tvOS apps that
builds on the best of C and Objective-C, without the constraints of C
compatibility. Swift adopts safe programming patterns and adds modern features
to make programming easier, more flexible, and more fun. Swiftâs clean slate,
backed by the mature and much-loved Cocoa and Cocoa Touch frameworks, is an
opportunity to reimagine how software development works.&lt;br&gt;&lt;br&gt; Swift has
been years in the making. Apple laid the foundation for Swift by advancing our
existing compiler, debugger, and framework infrastructure. We simplified
memory management with Automatic Reference Counting (ARC). Our framework
stack, built on the solid base of Foundation and Cocoa, has been modernized
and standardized throughout. Objective-C itself has evolved to support blocks,
collection literals, and modules, enabling framework adoption of modern
language technologies without disruption. Thanks to this groundwork, we can
now introduce a new language for the future of Apple software development.â&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Excerpt From: Apple Inc. â&lt;a href=&#34;https://itunes.apple.com/book/swift-programming-language/id881256329&#34;&gt;The Swift Programming Language (Swift 2.1)&lt;/a&gt;.â&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;now-i-can-give-you-my-opinion&#34;&gt;Now I can give you my opinion:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Swift makes for code that is easier &amp;amp; faster to write.&lt;/li&gt;
&lt;li&gt;Swift makes for code that is easier &amp;amp; cleaner to read (much more important
than ease of writing).&lt;/li&gt;
&lt;li&gt;Swift code is safer code.&lt;/li&gt;
&lt;li&gt;Swift breaks free from the out-dated conventions of C-based languages.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;When Apple announced Swift at WWDC 2105, I was astounded. That such a major
event could have been kept completely secret was amazing. Then I watched every
video from WWDC 2015 that discussed Swift. Some were beyond me and others I
absorbed. Looking back, I can see that the development of Objective-C over the
past few years was all aimed at getting to this point, especially with the
introduction of ARC and blocks.&lt;/p&gt;

&lt;p&gt;At that time, I was deeply involved in an existing Objective-C project and not
able to do much in Swift. But I went through the introduction at the start of
the &lt;a href=&#34;https://itunes.apple.com/book/swift-programming-language/id881256329&#34;&gt;Swift Programming Language&lt;/a&gt; book in iBooks and was able to get some
ideas about how the language worked.&lt;/p&gt;

&lt;p&gt;Some months later, I was able to spend time on Swift. As a learning exercise, I
converted an existing Objective-C iOS app to Swift. As might be expected, I
really just wrote Objective-C code using Swift syntax. It took a lot more
learning before I was able to write Swift-y code instead of just translated
Objective-C. In future posts of this series, I hope to enable others to cross
that divide faster than I did.&lt;/p&gt;

&lt;p&gt;Now when I go back to an Objective-C app, I feel like I am walking a tight-rope.
When I use an NSArray, NSSet or NSDictionary, I think &amp;ldquo;How can I tell what sort
of objects are in that array?&amp;ldquo;. When I use an object, I think &amp;ldquo;What if that
object is nil?&amp;ldquo;. All of a sudden, code that appeared stable now feels random.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;One of the big things that people have latched onto with Swift is that it allows
functional programming. I plan several detailed posts on functional programming
in this series. But for now I would just recommend that you not worry about the
distinction between procedural &amp;amp; functional programming. Both have their
advocates and their detractors. Both have their advantages and disadvantages.
Just do what ever works for you and we can worry about this later.&lt;/p&gt;
</description>
</item>
    
    <item>
<title>Learning Swift - An Introduction</title>
<link>https://troz.net/post/2016/learning-swift-an-introduction/</link>
<pubDate>Tue, 09 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://troz.net/post/2016/learning-swift-an-introduction/</guid>
<description>

&lt;h2 id=&#34;welcome-to-learning-swift&#34;&gt;Welcome to Learning Swift.&lt;/h2&gt;

&lt;p&gt;This is the first post in what I hope will be an extensive series dealing with
the Swift language. Here are some of the questions I hope to answer:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Should I learn Swift? Why?&lt;/li&gt;
&lt;li&gt;Why is Swift so great?&lt;/li&gt;
&lt;li&gt;How should I start learning Swift?&lt;/li&gt;
&lt;li&gt;I already know Objective-C - how do I convert?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After that, I am planning a series of posts discussing the major differences of
Swift from the view point of an Objective-C programmer and the aspects of Swift
that I found difficult to grasp. Topics covered will include such things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;optionals&lt;/li&gt;
&lt;li&gt;closures&lt;/li&gt;
&lt;li&gt;functional programming&lt;/li&gt;
&lt;li&gt;protocols&lt;/li&gt;
&lt;li&gt;generics&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I am coming from a background of Objective-C, so many of my posts will be
dealing with aspects of Swift that are not familiar to Objective-C programmers.
I will not assume any Objective-C programming experience, but some features of
Swift that are new to me, will be familiar to people accustomed to other
languages.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;So let&amp;rsquo;s start by answering the first question:&lt;/p&gt;

&lt;h2 id=&#34;should-i-learn-swift&#34;&gt;Should I learn Swift?&lt;/h2&gt;

&lt;p&gt;If you are writing or planning apps for any Apple platform - YES.&lt;br&gt; If not,
wait until Swift is available for the platforms you need to support.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;why&#34;&gt;Why?&lt;/h2&gt;

&lt;h3 id=&#34;if-you-are-already-an-ios-or-mac-developer-yes&#34;&gt;If you are already an iOS or Mac developer: YES&lt;/h3&gt;

&lt;p&gt;This is the new language and Apple is very committed to it. Objective-C is not
going away any time soon, but Swift is where it is going to end up, so why not
make the jump now while the language is still in development? You have to accept
that fact that every release of Xcode is going to break your code, but the
automatic re-factoring works very well. And by moving to Swift now, you get the
chance to influence the direction of a new language. How often does that happen?&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;if-you-are-starting-to-learn-ios-or-mac-development-yes&#34;&gt;If you are starting to learn iOS or Mac development: YES&lt;/h3&gt;

&lt;p&gt;If you have no history with Objective-C, then do not waste your time learning
it. There is still a lot of sample code out there in Objective-C, but increasing
numbers of tutorial sites are using Swift and converting their existing
tutorials to Swift. It will help if you know just enough Objective-C to read it,
but you do not need to know enough to write it.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;if-you-do-not-program-for-mac-or-ios-not-yet&#34;&gt;If you do NOT program for Mac or iOS: NOT YET&lt;/h3&gt;

&lt;p&gt;Swift went open source in late 2015. This is a big deal and Apple&amp;rsquo;s plans for
Swift are quite clear. They want Swift to be such a main-stream language that it
is used instead of Java for basic computer science courses in universities. This
was never going to happen unless the language was open-source and
cross-platform. It is now open-source and available for &lt;a href=&#34;https://swift.org/download/#latest-development-snapshots&#34;&gt;Linux as well as
Mac/iOS&lt;/a&gt;. While Apple has not yet released any further ports, I think there
are more on the way for Raspberry Pi, Arduino and other embedded systems as well
as server-side Swift libraries like &lt;a href=&#34;http://perfect.org&#34;&gt;Perfect&lt;/a&gt;. I expect that a version for
Windows will not be far behind.&lt;/p&gt;
</description>
</item>
    
    <item>
<title>New Twitter account</title>
<link>https://troz.net/post/2016/new-twitter-account/</link>
<pubDate>Tue, 09 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://troz.net/post/2016/new-twitter-account/</guid>
<description>&lt;p&gt;I have started a new Twitter account so that I can provide rapid support to
users of my apps. Please contact me &lt;a href=&#34;https://twitter.com/trozware&#34;&gt;@trozware&lt;/a&gt; if you have any questions,
suggestions, bug reports or would just like to chat.&lt;/p&gt;

&lt;p&gt;I will also be using this account to promote my new &lt;a href=&#34;https://troz.net/post/2016-02-09-learning-swift-an-introduction/&#34;&gt;Learning Swift&lt;/a&gt; series.&lt;/p&gt;
</description>
</item>
    
  </channel>
</rss>